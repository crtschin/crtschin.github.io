<!doctype html><html lang=en><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="I revisit the topic of polyvariadic functions, building on a previous attempt by introducing type families to create a more streamlined implementation."><title>(Non-)Functional Ramblings - Roly, Oly, …, Polyvariadic Boogaloo</title><style>@font-face{font-family:fira code;font-style:normal;font-weight:300 700;font-display:swap;src:local("Fira Code"),local("FiraCode"),url(/css/fonts/FiraCode-92f16d3.woff2)format('woff2-variations')}@font-face{font-family:montserrat;font-style:normal;font-weight:100 900;font-display:swap;src:local("Montserrat"),url(/css/fonts/Montserrat-92f16d3.woff2)format('woff2-variations')}@font-face{font-family:montserrat;font-style:italic;font-weight:100 900;font-display:swap;src:local("Montserrat Italic"),local("Montserrat-Italic"),url(/css/fonts/Montserrat-Italic-92f16d3.woff2)format('woff2-variations')}html{font-size:80%;font-weight:400;font-family:montserrat,arial,sans-serif;scroll-behavior:smooth;scrollbar-gutter:stable}html{text-size-adjust:none}*,*::before,*::after{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;-ms-box-sizing:border-box;-o-box-sizing:border-box;box-sizing:border-box}body{line-height:1.5;-webkit-font-smoothing:antialiased}input,button,textarea,select{font:inherit}p,h1,h2,h3,h4,h5,h6{overflow-wrap:break-word}#root,#__next{isolation:isolate}body{font-size:1.6rem;background-color:#282828;color:#fbf1c7}code,pre{background-color:#1d2021}header{border-bottom:.2rem solid #98971a}nav a{font-weight:700;text-decoration:none}body img{max-width:100%;max-height:100%;display:block;margin:auto;height:auto;width:auto}body figcaption{text-align:center}footer{margin-top:3rem;padding:1.2rem 0;border-top:.2rem solid #98971a;font-size:1.2rem;color:#fbf1c7}h1{font-size:2.4rem}h2{font-size:2rem}h3{font-size:1.8rem}h4{font-size:1.6rem}.title{margin-bottom:0}article .publish-date{margin:0 0 2rem 1rem;font-size:1.4rem;color:#fbf1c7}article .last-modified-date{font-size:1rem}.logo a{font-weight:700;color:#fbf1c7;text-decoration:none}blockquote{margin:1rem 0;padding:.5rem;border-radius:.5rem .5rem .5rem .5rem;border-left:.3rem solid #98971a;background-color:#1d2021;color:#fbf1c7}html{scrollbar-width:thick;scrollbar-color:#928374 #282828}pre{scrollbar-width:thin;scrollbar-color:#928374 #282828}nav.toc{float:left;clear:left;font-size:2rem;margin-left:-28%;width:20rem;word-wrap:break-word;padding:1rem;vertical-align:baseline;position:-webkit-sticky;position:sticky;top:5vh}nav.toc a{font-size:1.4rem}nav.toc ::marker{margin:0 -1rem 0 0}nav.toc li{margin:0;padding:0;line-height:1.2}nav.toc .toc-header{font-weight:700}nav.toc ul li{list-style-position:outside}nav.toc ul{margin-top:0;margin-bottom:0}pre,code{width:100%;font-family:fira code,consolas,monospace}div.highlight.inline{display:inline}pre{white-space:pre;overflow:auto;margin:1rem 0;background-color:#1d2021;padding:1rem;border-radius:.5rem .5rem .5rem .5rem}code{word-break:break-word;padding:0 .4rem;border-radius:.3rem .3rem .3rem .3rem}html a:link{color:#689d6a;background-color:initial;text-decoration:underline}html a:visited{color:#689d6a;background-color:initial;text-decoration:underline}html a:hover{color:#8ec07c;background-color:initial;text-decoration:underline}html a:active{color:#8ec07c;background-color:initial;text-decoration:none}nav.header a:link{color:#689d6a;background-color:initial;text-decoration:none}nav.header a:visited{color:#689d6a;background-color:initial;text-decoration:none}nav.header a:hover{color:#8ec07c;background-color:initial;text-decoration:none}nav.header a:active{color:#8ec07c;background-color:initial;text-decoration:underline}nav.toc a:link{color:#689d6a;background-color:initial;text-decoration:none}nav.toc a:visited{color:#689d6a;background-color:initial;text-decoration:none}nav.toc a:hover{color:#8ec07c;background-color:initial;text-decoration:none}nav.toc a:active{color:#8ec07c;background-color:initial;text-decoration:underline}.sidenote,marginnote{width:20rem;clear:right;font-size:1.1rem;line-height:1.3;vertical-align:baseline}body{counter-set:sidenote-counter}.sidenote-number{counter-increment:sidenote-counter}.sidenote:before{content:counter(sidenote-counter)" ";position:relative;vertical-align:baseline;font-weight:700;font-size:1rem;top:-.5rem;font-size:.9em}.sidenote-number:after{content:counter(sidenote-counter);position:relative;vertical-align:baseline;font-weight:700;font-size:1rem;top:-.5rem;left:.1rem}blockquote .sidenote,blockquote .marginnote{margin-right:82%;min-width:59%;text-align:left}.sidenote>code{font-size:1rem}label.sidenote-number{display:inline-block;max-height:2rem}label.margin-toggle:not(.sidenote-number){display:none}input.margin-toggle{display:none}.post-list{margin-top:1rem}.post-list-item{margin-bottom:2rem}.post-list-item p{width:100%;margin:0}.post-description{padding-top:.5rem}.post-header-title{text-align:left}.post-header-date{text-align:right}@media all and (max-width:1439px){nav.toc{display:none}}@media all and (max-width:1439px){.sidenote,.marginnote{float:right;text-align:left;margin:1rem 0;padding-left:5%}}@media all and (min-width:1440px){.sidenote,.marginnote{float:right;margin-right:-30%;margin-top:.3rem;margin-bottom:0;position:relative}}@media all and (max-width:639px){body{width:100%;margin:0;padding:0 5%}header{margin:1rem 0}nav.header{margin:.5rem auto;text-align:center}footer{text-align:center}nav.header a{font-size:1.4rem;line-height:1.6}.logo{font-size:1.8rem}nav.header a{margin:0 .6rem}}@media all and (min-width:640px){body{width:70rem;margin:0 auto;padding:0}header{margin:0 0 3rem;padding:.6rem 0 .2rem}nav.header{display:flex;align-items:flex-end;justify-content:space-between;margin:0;text-align:right}nav.header a{font-size:1.8rem;margin:0 0 0 .6rem;display:inline}.navigation{justify-content:flex-end}footer{text-align:right}.logo{margin:0;text-align:left;font-size:2.4rem}}@media all and (max-width:1439px){.post-header{display:block}}@media all and (min-width:1440px){.post-header{display:flex}.post-header-title{padding-left:1rem}.post-description{padding-left:3rem;padding-top:.5rem}}pre{line-height:125%}td.linenos .normal{color:#3c4354;background-color:initial;padding-left:5px;padding-right:5px}span.linenos{color:#3c4354;background-color:initial;padding-left:5px;padding-right:5px}td.linenos .special{color:#3c4354;background-color:#ffffc0;padding-left:5px;padding-right:5px}span.linenos.special{color:#3c4354;background-color:#ffffc0;padding-left:5px;padding-right:5px}.hll{background-color:#6e7681}.c{color:#7e8aa1}.err{color:#f88f7f}.esc{color:#d4d2c8}.g{color:#d4d2c8}.k{color:#ffad66}.l{color:#d5ff80}.n{color:#d4d2c8}.o{color:#ffad66}.x{color:#d4d2c8}.p{color:#d4d2c8}.ch{color:#f88f7f;font-style:italic}.cm{color:#7e8aa1}.cp{color:#ffad66;font-weight:700}.cpf{color:#7e8aa1}.c1{color:#7e8aa1}.cs{color:#7e8aa1;font-style:italic}.gd{color:#f88f7f;background-color:#3d1e20}.ge{color:#d4d2c8;font-style:italic}.ges{color:#d4d2c8}.gr{color:#f88f7f}.gh{color:#d4d2c8}.gi{color:#6ad4af;background-color:#19362c}.go{color:#7e8aa1}.gp{color:#d4d2c8}.gs{color:#d4d2c8;font-weight:700}.gu{color:#d4d2c8}.gt{color:#f88f7f}.kc{color:#ffad66}.kd{color:#ffad66}.kn{color:#ffad66}.kp{color:#ffad66}.kr{color:#ffad66}.kt{color:#73d0ff}.ld{color:#d5ff80}.m{color:#dfbfff}.s{color:#d5ff80}.na{color:#ffd173}.nb{color:#ffd173}.nc{color:#73d0ff}.no{color:#ffd173}.nd{color:#7e8aa1;font-weight:700;font-style:italic}.ni{color:#95e6cb}.ne{color:#73d0ff}.nf{color:#ffd173}.nl{color:#d4d2c8}.nn{color:#d4d2c8}.nx{color:#d4d2c8}.py{color:#ffd173}.nt{color:#5ccfe6}.nv{color:#d4d2c8}.ow{color:#ffad66}.pm{color:#d4d2c8}.w{color:#d4d2c8}.mb{color:#dfbfff}.mf{color:#dfbfff}.mh{color:#dfbfff}.mi{color:#dfbfff}.mo{color:#dfbfff}.sa{color:#f29e74}.sb{color:#d5ff80}.sc{color:#d5ff80}.dl{color:#d5ff80}.sd{color:#7e8aa1}.s2{color:#d5ff80}.se{color:#95e6cb}.sh{color:#d5ff80}.si{color:#95e6cb}.sx{color:#95e6cb}.sr{color:#95e6cb}.s1{color:#d5ff80}.ss{color:#dfbfff}.bp{color:#5ccfe6}.fm{color:#ffd173}.vc{color:#d4d2c8}.vg{color:#d4d2c8}.vi{color:#d4d2c8}.vm{color:#d4d2c8}.il{color:#dfbfff}</style><link rel=preload href=../css/fonts/Montserrat-92f16d3.woff2 crossorigin=anonymous as=font type=font/woff2><link rel=stylesheet href=../css/katex.css media=print onload='this.media="all"'><noscript><link rel=stylesheet href=../css/katex.css></noscript><link rel="shortcut icon" href=favicon.ico type=image/x-icon><link rel="shortcut icon" href=../images/favicons/favicon32.png><link rel=apple-touch-icon-precomposed sizes=144x144 href=../images/favicons/favicon144.png><link rel=apple-touch-icon-precomposed sizes=114x114 href=../images/favicons/favicon114.png><link rel=apple-touch-icon-precomposed sizes=72x72 href=../images/favicons/favicon72.png><link rel=apple-touch-icon-precomposed sizes=57x57 href=../images/favicons/favicon57.png><header><nav class=header><a class=logo href=../>(Non-)Functional Ramblings</a><div class=navigation><a href=../about.html>About</a>
<a href=../static/resume.pdf>Resume</a>
<a href=../archive.html>Archive</a>
<a href=../atom.xml>Feed</a></div></nav></header><main role=main><h1 class=title>Roly, Oly, …, Polyvariadic Boogaloo</h1><article><section class=publish-date><em>Posted on September 18, 2020</em></section><section><blockquote>I revisit the topic of polyvariadic functions, building on a previous attempt by introducing type families to create a more streamlined implementation.</blockquote></section><section><p></p>I started this post not long after <a href=../roly-oly-poly/>its predecessor</a>, but ended up forgetting about it.<p></p>In the previous post about polyvariadic functions, we gave some examples of how to define them in haskell using typeclass trickery. The final definitions were, however, very repetitive, as we had to define a typeclass for each of the functions. Our handy list of our ghc-specific language extensions.<div class=highlight><pre tabindex=0><span></span><span class=cm>{-# LANGUAGE DefaultSignatures #-}</span>
<span class=cm>{-# LANGUAGE FlexibleContexts #-}</span>
<span class=cm>{-# LANGUAGE FlexibleInstances #-}</span>
<span class=cm>{-# LANGUAGE InstanceSigs #-}</span>
<span class=cm>{-# LANGUAGE MultiParamTypeClasses #-}</span>
<span class=cm>{-# LANGUAGE TypeFamilies #-}</span>
</pre></div><p></p>In the previous post, while I did mention type families, I did not use them anywhere. Functional dependencies are an alternative, but the general concensus is to move away from these due to inference problems.<p></p>Like functions are to terms, type families are to types. Type families enable you to write type level functions. We’re going to use this to implement some way of determining what the result type is of a function.<div class=highlight><pre tabindex=0><span></span><span class=kr>type</span><span class=w> </span><span class=kr>family</span><span class=w> </span><span class=kt>PolyRes</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=kr>where</span>
<span class=w>    </span><span class=kt>PolyRes</span><span class=w> </span><span class=p>(</span><span class=n>a</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=n>r</span><span class=p>)</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=kt>PolyRes</span><span class=w> </span><span class=n>r</span>
<span class=w>    </span><span class=kt>PolyRes</span><span class=w> </span><span class=n>r</span><span class=w>        </span><span class=ow>=</span><span class=w> </span><span class=n>r</span>
</pre></div><p></p>This definition essentially recursively searches for the result type by proceeding into the right-hand side of function types. So a type signature like <code>Int -> Int -> Int -> [Int]</code>, which we would like <code>append</code> to have in <code>append 1 2 3</code>, would map to <code>[Int]</code>. We can use this type family to define generic variants of the various typeclasses from the previous post. In this particular instance, we will attempt to write a polyvariadic variant of the fold function using this <code>Poly</code> typeclass.<p></p>The typical type signature of a fold function, using <code>foldr</code> as an example, follows <code>(a -> b -> b) -> b -> [a] -> b</code>, where <code>a</code> is the argument type and <code>b</code> is the result type. We can use this as inspiration to determine what the type signature will be of our generic polyvariant fold. We already know <code>PolyRes r</code> will represent our result type, so the expression becomes <code>(a -> PolyRes r -> PolyRes r) -> PolyRes r -> [a] -> r</code>. Note that the last instance of <code>r</code> isn’t prefixed by PolyRes, this is because we will be outputting the polyvariant function, not its result. Finally, we can also remove the argument list <code>[a]</code> as our arguments will be coming in incrementally at each instance resolution step at function type, <code>a -> r</code>. So our final type signature is <code>(a -> PolyRes r -> PolyRes r) -> PolyRes r -> r</code>.<div class=highlight><pre tabindex=0><span></span><span class=kr>class</span><span class=w> </span><span class=kt>Poly</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=kr>where</span>
<span class=w>  </span><span class=n>poly</span><span class=w> </span><span class=ow>::</span><span class=w> </span><span class=p>(</span><span class=n>a</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=kt>PolyRes</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=kt>PolyRes</span><span class=w> </span><span class=n>r</span><span class=p>)</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=kt>PolyRes</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=n>r</span>
</pre></div><p></p>This definition, however, would require that the user would have to define an annoying amount of superfluous instances. To see why, remember how a fold is usually defined.<div class=highlight><pre tabindex=0><span></span><span class=nf>foldr</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>z</span><span class=w> </span><span class=kt>[]</span><span class=w>       </span><span class=ow>=</span><span class=w> </span><span class=n>z</span>
<span class=nf>foldr</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>z</span><span class=w> </span><span class=p>(</span><span class=n>x</span><span class=w> </span><span class=kt>:</span><span class=w> </span><span class=n>xs</span><span class=p>)</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=p>(</span><span class=n>foldr</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>xs</span><span class=p>)</span>
</pre></div><p></p>As we’re working with typeclasses, we will have to implement the first or base case of <code>foldr</code> as an instance for each of the types we want to use as a result type of our function. This amounts to the following boilerplate.<div class=highlight><pre tabindex=0><span></span><span class=kr>instance</span><span class=w> </span><span class=kt>Poly</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=kt>Bool</span><span class=w> </span><span class=kr>where</span>
<span class=w>  </span><span class=n>poly</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>r</span>

<span class=kr>instance</span><span class=w> </span><span class=kt>Poly</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=kt>Int</span><span class=w> </span><span class=kr>where</span>
<span class=w>  </span><span class=n>poly</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>r</span>
</pre></div><p></p>Using the default instance language extension, we can define the base case of the fold straight into the typeclass itself. So our typeclass definition now becomes:<div class=highlight><pre tabindex=0><span></span><span class=kr>class</span><span class=w> </span><span class=kt>Poly</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=kr>where</span>
<span class=w>  </span><span class=n>poly</span><span class=w> </span><span class=ow>::</span><span class=w> </span><span class=p>(</span><span class=n>a</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=kt>PolyRes</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=kt>PolyRes</span><span class=w> </span><span class=n>r</span><span class=p>)</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=kt>PolyRes</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=n>r</span>
<span class=w>  </span><span class=kr>default</span><span class=w> </span><span class=n>poly</span><span class=w> </span><span class=ow>::</span><span class=w> </span><span class=p>(</span><span class=n>r</span><span class=w> </span><span class=o>~</span><span class=w> </span><span class=kt>PolyRes</span><span class=w> </span><span class=n>r</span><span class=p>)</span><span class=w> </span><span class=ow>=&gt;</span>
<span class=w>    </span><span class=p>(</span><span class=n>a</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=kt>PolyRes</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=kt>PolyRes</span><span class=w> </span><span class=n>r</span><span class=p>)</span><span class=w> </span><span class=ow>-&gt;</span>
<span class=w>    </span><span class=kt>PolyRes</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=n>r</span>
<span class=w>  </span><span class=n>poly</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>r</span>

<span class=kr>instance</span><span class=w> </span><span class=kt>Poly</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=kt>Bool</span>
<span class=kr>instance</span><span class=w> </span><span class=kt>Poly</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=kt>Integer</span>
<span class=kr>instance</span><span class=w> </span><span class=kt>Poly</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=p>[</span><span class=n>r</span><span class=p>]</span>
</pre></div><p></p>The above definition of <code>poly</code> in our typeclass kind of encompasses what we would expect the base case of a <code>fold</code> function to look like. The combining step, we will implement using our instance for function terms, where we assert that we have an argument of type <code>a</code> compatible with the function given to <code>poly</code>, <code>a -> PolyRes r -> PolyRes r</code>.<div class=highlight><pre tabindex=0><span></span><span class=kr>instance</span><span class=w> </span><span class=kt>Poly</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=ow>=&gt;</span><span class=w> </span><span class=kt>Poly</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=p>(</span><span class=n>a</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=n>r</span><span class=p>)</span><span class=w> </span><span class=kr>where</span>
<span class=w>  </span><span class=n>poly</span><span class=w> </span><span class=ow>::</span><span class=w> </span><span class=p>(</span><span class=n>a</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=kt>PolyRes</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=kt>PolyRes</span><span class=w> </span><span class=n>r</span><span class=p>)</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=kt>PolyRes</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=n>r</span>
<span class=w>  </span><span class=n>poly</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>poly</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=p>(</span><span class=n>f</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=n>r</span><span class=p>)</span>
</pre></div><p></p>This instance for function types can be interpreted as: each time poly is treated as a function, we have an argument of type <code>a</code> that we can use to do a single application of the fold. After which we proceed with a recursive call to <code>poly</code>.<p></p>Now we can straightforwardly define polyvariadic variants of common list functions. Note that the type signatures are required as otherwise, the type checker has problems inferring the correct types. Unfortunately, the <code>PolyRes r ~ whatever</code> type equality constraints don’t provide ghc with enough type information to be able to use the below functions ‘as is’. They have to be type annotated on usage, so in the form of <code>cons' True False True :: [Bool]</code>, etc.<div class=highlight><pre tabindex=0><span></span><span class=nf>and'</span><span class=w> </span><span class=ow>::</span><span class=w> </span><span class=p>(</span><span class=kt>Poly</span><span class=w> </span><span class=kt>Bool</span><span class=w> </span><span class=n>r</span><span class=p>,</span><span class=w> </span><span class=kt>PolyRes</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=o>~</span><span class=w> </span><span class=kt>Bool</span><span class=p>)</span><span class=w> </span><span class=ow>=&gt;</span><span class=w> </span><span class=n>r</span>
<span class=nf>and'</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>poly</span><span class=w> </span><span class=p>(</span><span class=o>&amp;&amp;</span><span class=p>)</span><span class=w> </span><span class=kt>True</span>

<span class=nf>or'</span><span class=w> </span><span class=ow>::</span><span class=w> </span><span class=p>(</span><span class=kt>Poly</span><span class=w> </span><span class=kt>Bool</span><span class=w> </span><span class=n>r</span><span class=p>,</span><span class=w> </span><span class=kt>PolyRes</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=o>~</span><span class=w> </span><span class=kt>Bool</span><span class=p>)</span><span class=w> </span><span class=ow>=&gt;</span><span class=w> </span><span class=n>r</span>
<span class=nf>or'</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>poly</span><span class=w> </span><span class=p>(</span><span class=o>||</span><span class=p>)</span><span class=w> </span><span class=kt>False</span>

<span class=nf>cons'</span><span class=w> </span><span class=ow>::</span><span class=w> </span><span class=p>(</span><span class=kt>Poly</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=n>r</span><span class=p>,</span><span class=w> </span><span class=kt>PolyRes</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=o>~</span><span class=w> </span><span class=p>[</span><span class=n>a</span><span class=p>])</span><span class=w> </span><span class=ow>=&gt;</span><span class=w> </span><span class=n>r</span>
<span class=nf>cons'</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>poly</span><span class=w> </span><span class=p>(</span><span class=kt>:</span><span class=p>)</span><span class=w> </span><span class=kt>[]</span>

<span class=nf>fold'</span><span class=w> </span><span class=ow>::</span><span class=w> </span><span class=p>(</span><span class=kt>Poly</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=n>r</span><span class=p>,</span><span class=w> </span><span class=kt>PolyRes</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=o>~</span><span class=w> </span><span class=n>s</span><span class=p>)</span><span class=w> </span><span class=ow>=&gt;</span><span class=w> </span><span class=p>(</span><span class=n>a</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=n>s</span><span class=p>)</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=n>r</span>
<span class=nf>fold'</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>poly</span>
</pre></div><p></p><em>As an excercise, try implementing a variation of <code>Poly</code> that gathers the given arguments in a list and then applies a function <code>[a] -> PolyRes r</code>. This variant could be used to convert any function on lists to its corresponding polyvariadic counterpart.</em></section></article></main><footer>Site proudly generated by <a href=http://jaspervdj.be/hakyll>Hakyll</a>.
All content is licensed under <a href=../LICENSE.txt>3-clause BSD license</a>.</footer>