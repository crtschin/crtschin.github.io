<!doctype html><html lang=en><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Briefly explore the concept of catamorphisms in functional programming, primarily focusing on their application to algebraic data types, such as binary trees."><title>(Non-)Functional Ramblings - Cat… amarphisms</title><style>@font-face{font-family:fira code;font-style:normal;font-weight:300 700;font-display:swap;src:local("Fira Code"),local("FiraCode"),url(/css/fonts/FiraCode-ccd732d.woff2)format('woff2-variations')}@font-face{font-family:montserrat;font-style:normal;font-weight:100 900;font-display:swap;src:local("Montserrat"),url(/css/fonts/Montserrat-ccd732d.woff2)format('woff2-variations')}@font-face{font-family:montserrat;font-style:italic;font-weight:100 900;font-display:swap;src:local("Montserrat Italic"),local("Montserrat-Italic"),url(/css/fonts/Montserrat-Italic-ccd732d.woff2)format('woff2-variations')}html{font-size:80%;font-weight:400;font-family:montserrat,arial,sans-serif;scroll-behavior:smooth;scrollbar-gutter:stable}html{text-size-adjust:none}*,*::before,*::after{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;-ms-box-sizing:border-box;-o-box-sizing:border-box;box-sizing:border-box}body{line-height:1.5;-webkit-font-smoothing:antialiased}input,button,textarea,select{font:inherit}p,h1,h2,h3,h4,h5,h6{overflow-wrap:break-word}#root,#__next{isolation:isolate}body{font-size:1.6rem;background-color:#282828;color:#fbf1c7}code,pre{background-color:#1d2021}header{border-bottom:.2rem solid #98971a}nav a{font-weight:700;text-decoration:none}body img{max-width:100%;max-height:100%;display:block;margin:auto;height:auto}body figcaption{text-align:center}footer{margin-top:3rem;padding:1.2rem 0;border-top:.2rem solid #98971a;font-size:1.2rem;color:#fbf1c7}h1{font-size:2.4rem}h2{font-size:2rem}h3{font-size:1.8rem}h4{font-size:1.6rem}.title{margin-bottom:0}article .publish-date{margin:0 0 2rem 1rem;font-size:1.4rem;color:#fbf1c7}.logo a{font-weight:700;color:#fbf1c7;text-decoration:none}html{scrollbar-width:thick;scrollbar-color:#928374 #282828}pre{scrollbar-width:thin;scrollbar-color:#928374 #282828}nav.toc{float:left;clear:left;font-size:2rem;margin-left:-28%;width:20rem;word-wrap:break-word;padding:1rem;vertical-align:baseline;position:-webkit-sticky;position:sticky;top:5vh}nav.toc a{font-size:1.4rem}nav.toc ::marker{margin:0 -1rem 0 0}nav.toc li{margin:0;padding:0;line-height:1.2}nav.toc .toc-header{font-weight:700}nav.toc ul li{list-style-position:outside}nav.toc ul{margin-top:0;margin-bottom:0}pre,code{font-family:fira code,consolas,monospace}div.highlight.inline{display:inline}pre{white-space:pre;overflow:auto;margin:1rem 0;background-color:#1d2021;padding:1rem;border-radius:.5rem .5rem .5rem .5rem}code{word-break:break-word;padding:0 .4rem;border-radius:.3rem .3rem .3rem .3rem}html a:link{color:#689d6a;background-color:initial;text-decoration:underline}html a:visited{color:#689d6a;background-color:initial;text-decoration:underline}html a:hover{color:#8ec07c;background-color:initial;text-decoration:underline}html a:active{color:#8ec07c;background-color:initial;text-decoration:none}nav.header a:link{color:#689d6a;background-color:initial;text-decoration:none}nav.header a:visited{color:#689d6a;background-color:initial;text-decoration:none}nav.header a:hover{color:#8ec07c;background-color:initial;text-decoration:none}nav.header a:active{color:#8ec07c;background-color:initial;text-decoration:underline}nav.toc a:link{color:#689d6a;background-color:initial;text-decoration:none}nav.toc a:visited{color:#689d6a;background-color:initial;text-decoration:none}nav.toc a:hover{color:#8ec07c;background-color:initial;text-decoration:none}nav.toc a:active{color:#8ec07c;background-color:initial;text-decoration:underline}.sidenote,marginnote{width:20rem;font-size:1.1rem;line-height:1.3;vertical-align:baseline}body{counter-set:sidenote-counter}.sidenote-number{counter-increment:sidenote-counter}.sidenote:before{content:counter(sidenote-counter)" ";position:relative;vertical-align:baseline;font-weight:700;font-size:1rem;top:-.5rem;font-size:.9em}.sidenote-number:after{content:counter(sidenote-counter);position:relative;vertical-align:baseline;font-weight:700;font-size:1rem;top:-.5rem;left:.1rem}blockquote .sidenote,blockquote .marginnote{margin-right:82%;min-width:59%;text-align:left}.sidenote>code{font-size:1rem}label.sidenote-number{display:inline-block;max-height:2rem}label.margin-toggle:not(.sidenote-number){display:none}input.margin-toggle{display:none}@media all and (max-width:1439px){nav.toc{display:none}}@media all and (max-width:1439px){.sidenote,.marginnote{float:right;text-align:left;margin:1rem 0;padding-left:5%}}@media all and (min-width:1440px){.sidenote,.marginnote{float:right;clear:right;margin-right:-30%;margin-top:.3rem;margin-bottom:0;position:relative}}@media all and (max-width:639px){body{width:100%;margin:0;padding:0 5%}header{margin:1rem 0}nav.header{margin:.5rem auto;text-align:center}footer{text-align:center}nav.header a{font-size:1.4rem;line-height:1.6}.logo{font-size:1.8rem}nav.header a{margin:0 .6rem}}@media all and (min-width:640px){body{width:70rem;margin:0 auto;padding:0}header{margin:0 0 3rem;padding:.6rem 0 .2rem}nav.header{display:flex;align-items:flex-end;justify-content:space-between;margin:0;text-align:right}nav.header a{font-size:1.8rem;margin:0 0 0 .6rem;display:inline}.navigation{justify-content:flex-end}footer{text-align:right}.logo{margin:0;text-align:left;font-size:2.4rem}}pre{line-height:125%}td.linenos .normal{color:#3c4354;background-color:initial;padding-left:5px;padding-right:5px}span.linenos{color:#3c4354;background-color:initial;padding-left:5px;padding-right:5px}td.linenos .special{color:#3c4354;background-color:#ffffc0;padding-left:5px;padding-right:5px}span.linenos.special{color:#3c4354;background-color:#ffffc0;padding-left:5px;padding-right:5px}.hll{background-color:#6e7681}.c{color:#7e8aa1}.err{color:#f88f7f}.esc{color:#d4d2c8}.g{color:#d4d2c8}.k{color:#ffad66}.l{color:#d5ff80}.n{color:#d4d2c8}.o{color:#ffad66}.x{color:#d4d2c8}.p{color:#d4d2c8}.ch{color:#f88f7f;font-style:italic}.cm{color:#7e8aa1}.cp{color:#ffad66;font-weight:700}.cpf{color:#7e8aa1}.c1{color:#7e8aa1}.cs{color:#7e8aa1;font-style:italic}.gd{color:#f88f7f;background-color:#3d1e20}.ge{color:#d4d2c8;font-style:italic}.ges{color:#d4d2c8}.gr{color:#f88f7f}.gh{color:#d4d2c8}.gi{color:#6ad4af;background-color:#19362c}.go{color:#7e8aa1}.gp{color:#d4d2c8}.gs{color:#d4d2c8;font-weight:700}.gu{color:#d4d2c8}.gt{color:#f88f7f}.kc{color:#ffad66}.kd{color:#ffad66}.kn{color:#ffad66}.kp{color:#ffad66}.kr{color:#ffad66}.kt{color:#73d0ff}.ld{color:#d5ff80}.m{color:#dfbfff}.s{color:#d5ff80}.na{color:#ffd173}.nb{color:#ffd173}.nc{color:#73d0ff}.no{color:#ffd173}.nd{color:#7e8aa1;font-weight:700;font-style:italic}.ni{color:#95e6cb}.ne{color:#73d0ff}.nf{color:#ffd173}.nl{color:#d4d2c8}.nn{color:#d4d2c8}.nx{color:#d4d2c8}.py{color:#ffd173}.nt{color:#5ccfe6}.nv{color:#d4d2c8}.ow{color:#ffad66}.pm{color:#d4d2c8}.w{color:#d4d2c8}.mb{color:#dfbfff}.mf{color:#dfbfff}.mh{color:#dfbfff}.mi{color:#dfbfff}.mo{color:#dfbfff}.sa{color:#f29e74}.sb{color:#d5ff80}.sc{color:#d5ff80}.dl{color:#d5ff80}.sd{color:#7e8aa1}.s2{color:#d5ff80}.se{color:#95e6cb}.sh{color:#d5ff80}.si{color:#95e6cb}.sx{color:#95e6cb}.sr{color:#95e6cb}.s1{color:#d5ff80}.ss{color:#dfbfff}.bp{color:#5ccfe6}.fm{color:#ffd173}.vc{color:#d4d2c8}.vg{color:#d4d2c8}.vi{color:#d4d2c8}.vm{color:#d4d2c8}.il{color:#dfbfff}</style><link rel=preload href=../css/fonts/Montserrat-ccd732d.woff2 crossorigin=anonymous as=font type=font/woff2><link rel=stylesheet href=../css/katex.css media=print onload='this.media="all"'><noscript><link rel=stylesheet href=../css/katex.css></noscript><link rel="shortcut icon" href=favicon.ico type=image/x-icon><link rel="shortcut icon" href=../images/favicons/favicon32.png><link rel=apple-touch-icon-precomposed sizes=144x144 href=../images/favicons/favicon144.png><link rel=apple-touch-icon-precomposed sizes=114x114 href=../images/favicons/favicon114.png><link rel=apple-touch-icon-precomposed sizes=72x72 href=../images/favicons/favicon72.png><link rel=apple-touch-icon-precomposed sizes=57x57 href=../images/favicons/favicon57.png><header><nav class=header><a class=logo href=../>(Non-)Functional Ramblings</a><div class=navigation><a href=../about.html>About</a>
<a href=../static/resume.pdf>Resume</a>
<a href=../archive.html>Archive</a>
<a href=../atom.xml>Feed</a></div></nav></header><main role=main><h1 class=title>Cat… amarphisms</h1><article><section class=publish-date><em>Posted on April 15, 2018</em></section><section><p></p>One of the first higher-order functions most students encounter in a functional programming course is the fold (foldr, foldl). A fold takes an operator, an initial value and a list, and then recursively combines each element in the list using the initial value and the given operator.<figure><img src=../images/Right-fold-transformation-1-.png alt="The recursive combining structure of a fold"><figcaption aria-hidden=true>The recursive combining structure of a fold</figcaption></figure><h2 id=the-easy-stuff>The Easy Stuff</h2><p></p>A catamorphism is a generalization of the fold on lists<label for=sn-0 class="margin-toggle sidenote-number"></label><input type=checkbox id=sn-0 class=margin-toggle><div class=sidenote><a href=https://www.schoolofhaskell.com/user/edwardk/recursion-schemes/catamorphisms>Kmett, E. (2014, 15 Apr) Catamorphisms. School of Haskell</a></div>. The word catamorphism has its roots in the Greek word ‘κατά’ meaning ‘downwards’<label for=sn-1 class="margin-toggle sidenote-number"></label><input type=checkbox id=sn-1 class=margin-toggle><div class=sidenote>(HaskellWiki, Catamorphisms)[<a href=https://wiki.haskell.org/Catamorphisms class=uri>https://wiki.haskell.org/Catamorphisms</a>]</div>. In this case it is the concept of applying a fold on any algebraic data type. An algebraic data type is any data type composed of other types – as an example, take the following data type for a binary tree I will use throughout this post.<div class=highlight><pre tabindex=0><span></span><span class=kr>data</span><span class=w> </span><span class=kt>Tree</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=kt>Empty</span>
<span class=w>  </span><span class=o>|</span><span class=w> </span><span class=kt>Leaf</span><span class=w> </span><span class=n>a</span>
<span class=w>  </span><span class=o>|</span><span class=w> </span><span class=kt>Node</span><span class=w> </span><span class=p>(</span><span class=kt>Tree</span><span class=w> </span><span class=n>a</span><span class=p>)</span><span class=w> </span><span class=p>(</span><span class=kt>Tree</span><span class=w> </span><span class=n>a</span><span class=p>)</span>
</pre></div><p></p>The following two functions both take such a Tree and recursively combines it into an Int. The first function calculates the depth, and the second how many leaves are in the tree.<div class=highlight><pre tabindex=0><span></span><span class=nf>depth</span><span class=w> </span><span class=ow>::</span><span class=w> </span><span class=kt>Tree</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=kt>Int</span>
<span class=nf>depth</span><span class=w> </span><span class=kt>Empty</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=mi>0</span>
<span class=nf>depth</span><span class=w> </span><span class=p>(</span><span class=kt>Leaf</span><span class=w> </span><span class=n>a</span><span class=p>)</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=mi>1</span>
<span class=nf>depth</span><span class=w> </span><span class=p>(</span><span class=kt>Node</span><span class=w> </span><span class=n>l</span><span class=w> </span><span class=n>r</span><span class=p>)</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>max</span><span class=w> </span><span class=p>(</span><span class=n>depth</span><span class=w> </span><span class=n>l</span><span class=p>)</span><span class=w> </span><span class=p>(</span><span class=n>depth</span><span class=w> </span><span class=n>r</span><span class=p>)</span>

<span class=nf>count</span><span class=w> </span><span class=ow>::</span><span class=w> </span><span class=kt>Tree</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=kt>Int</span>
<span class=nf>count</span><span class=w> </span><span class=kt>Empty</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=mi>0</span>
<span class=nf>count</span><span class=w> </span><span class=p>(</span><span class=kt>Leaf</span><span class=w> </span><span class=n>a</span><span class=p>)</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=mi>1</span>
<span class=nf>count</span><span class=w> </span><span class=p>(</span><span class=kt>Node</span><span class=w> </span><span class=n>l</span><span class=w> </span><span class=n>r</span><span class=p>)</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=p>(</span><span class=o>+</span><span class=p>)</span><span class=w> </span><span class=p>(</span><span class=n>count</span><span class=w> </span><span class=n>l</span><span class=p>)</span><span class=w> </span><span class=p>(</span><span class=n>count</span><span class=w> </span><span class=n>r</span><span class=p>)</span>
</pre></div><p></p>I think you can quickly see where I am going with this. These two functions both have the same structure, where for each constructor there is a function which takes some values and outputs something, sometimes recursively. Note the types of the functions used on the right-hand side of both depth and count.<p></p>The type signature of the function used when handling an Empty is just an Int. For a Leaf a we implicitly get some type a, which is then thrown away, and give an Int so its type is (a -> Int). The (+) in the case of the count function for a Node takes 2 parameters, both Ints. So, when trying to generalise count and depth we need some group of functions (Int, a -> Int, Int -> Int -> Int) for the different cases. We can now define the generic function we will use to create depth and count.<div class=highlight><pre tabindex=0><span></span><span class=nf>foldTreeToInt</span><span class=w> </span><span class=ow>::</span><span class=w> </span><span class=p>(</span><span class=kt>Int</span><span class=p>,</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=kt>Int</span><span class=p>,</span><span class=w> </span><span class=kt>Int</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=kt>Int</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=kt>Int</span><span class=p>)</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=kt>Tree</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=kt>Int</span>
<span class=nf>foldTreeToInt</span><span class=w> </span><span class=p>(</span><span class=n>empty</span><span class=p>,</span><span class=w> </span><span class=n>leaf</span><span class=p>,</span><span class=w> </span><span class=n>node</span><span class=p>)</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>fTreeToInt</span>
<span class=w>  </span><span class=kr>where</span>
<span class=w>    </span><span class=n>fTreeToInt</span><span class=w> </span><span class=kt>Empty</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>empty</span>
<span class=w>    </span><span class=n>fTreeToInt</span><span class=w> </span><span class=p>(</span><span class=kt>Leaf</span><span class=w> </span><span class=n>a</span><span class=p>)</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>leaf</span><span class=w> </span><span class=n>a</span>
<span class=w>    </span><span class=n>fTreeToInt</span><span class=w> </span><span class=p>(</span><span class=kt>Node</span><span class=w> </span><span class=n>l</span><span class=w> </span><span class=n>r</span><span class=p>)</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>node</span><span class=w> </span><span class=p>(</span><span class=n>fTreeToInt</span><span class=w> </span><span class=n>l</span><span class=p>)</span><span class=w> </span><span class=p>(</span><span class=n>fTreeToInt</span><span class=w> </span><span class=n>r</span><span class=p>)</span>

<span class=c1>-- We can now easily define depth and count by specifying</span>
<span class=c1>-- the group of functions</span>
<span class=nf>depth'</span><span class=w> </span><span class=ow>::</span><span class=w> </span><span class=kt>Tree</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=kt>Int</span>
<span class=nf>depth'</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>foldTreeToInt</span><span class=w> </span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=n>const</span><span class=w> </span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=nf>\</span><span class=n>l</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>max</span><span class=w> </span><span class=n>l</span><span class=w> </span><span class=n>r</span><span class=p>)</span>

<span class=nf>count'</span><span class=w> </span><span class=ow>::</span><span class=w> </span><span class=kt>Tree</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=kt>Int</span>
<span class=nf>count'</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>foldTreeToInt</span><span class=w> </span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=n>const</span><span class=w> </span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=p>(</span><span class=o>+</span><span class=p>))</span>
</pre></div><p></p>The group of functions needed for the fold is called an F-algebra and maintains the structure of the underlying algebraic data type<label for=sn-2 class="margin-toggle sidenote-number"></label><input type=checkbox id=sn-2 class=margin-toggle><div class=sidenote>Jeuring, J., Swierstra, D. (2011) Languages And Compilers. Utrecht University</div>. We can generalise the fold we created to generic data types.<div class=highlight><pre tabindex=0><span></span><span class=kr>type</span><span class=w> </span><span class=kt>TreeAlgebra</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=n>t</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=p>(</span><span class=n>t</span><span class=p>,</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=n>t</span><span class=p>,</span><span class=w> </span><span class=n>t</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=n>t</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=n>t</span><span class=p>)</span>

<span class=nf>foldTree</span><span class=w> </span><span class=ow>::</span><span class=w> </span><span class=kt>TreeAlgebra</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=n>t</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=kt>Tree</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=n>t</span>
<span class=nf>foldTree</span><span class=w> </span><span class=p>(</span><span class=n>empty</span><span class=p>,</span><span class=w> </span><span class=n>leaf</span><span class=p>,</span><span class=w> </span><span class=n>node</span><span class=p>)</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>fTree</span>
<span class=w>  </span><span class=kr>where</span>
<span class=w>    </span><span class=n>fTree</span><span class=w> </span><span class=kt>Empty</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>empty</span>
<span class=w>    </span><span class=n>fTree</span><span class=w> </span><span class=p>(</span><span class=kt>Leaf</span><span class=w> </span><span class=n>a</span><span class=p>)</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>leaf</span><span class=w> </span><span class=n>a</span>
<span class=w>    </span><span class=n>fTree</span><span class=w> </span><span class=p>(</span><span class=kt>Node</span><span class=w> </span><span class=n>l</span><span class=w> </span><span class=n>r</span><span class=p>)</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>node</span><span class=w> </span><span class=p>(</span><span class=n>fTree</span><span class=w> </span><span class=n>l</span><span class=p>)</span><span class=w> </span><span class=p>(</span><span class=n>fTree</span><span class=w> </span><span class=n>r</span><span class=p>)</span>
</pre></div><p></p>When the constructors are used as the functions in the algebra, we get as output the same tree. This specific algebra is called the initial algebra and defines the identity function. The count and depth functions created using the algebra and fold are called compositional functions.<h2 id=black-magic>Black magic</h2><p></p>Catamorphism is a term from category theory, of which my knowledge is anything but formal (or correct). Best to hear it from someone who knows what they are talking <a href=http://chrislambda.github.io/blog/2014/01/30/catamorphisms-in-15-minutes/>about</a><label for=sn-3 class="margin-toggle sidenote-number"></label><input type=checkbox id=sn-3 class=margin-toggle><div class=sidenote><a href=http://chrislambda.github.io/blog/2014/01/30/catamorphisms-in-15-minutes/>Jones, C (2014, 30 Jan) Catamorphisms in 15 Minutes!</a></div>.<p></p>A F-algebra contains an endofunctor <code>f</code>, an object <code>a</code> and a morphism <code>f a -> a</code><label for=sn-4 class="margin-toggle sidenote-number"></label><input type=checkbox id=sn-4 class=margin-toggle><div class=sidenote><a href=https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/>Milewski, B. (2014) Category Theory for Programmers</a></div>. A functor is a mapping between categories, where an endofunctor maps a category into itself. This can be written in haskell as type <code>Algebra f a = f a -> a</code><label for=sn-5 class="margin-toggle sidenote-number"></label><input type=checkbox id=sn-5 class=margin-toggle><div class=sidenote><a href=https://www.schoolofhaskell.com/user/bartosz/understanding-algebras>Milewski, B. (2013, 1 Oct) Understanding F-Algebras. School of Haskell</a></div>.<p></p>We can use fixed points as our initial algebra. A fixed point here is when you can apply some functor f to itself and get the same type, possible in haskell as <code>newtype Fix f = Fix { unFix :: f (Fix f) }</code>. The code for writing generic catamorphisms can now be written as.<div class=highlight><pre tabindex=0><span></span><span class=kr>type</span><span class=w> </span><span class=kt>Algebra</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=n>a</span>
<span class=kr>newtype</span><span class=w> </span><span class=kt>Fix</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=kt>Fix</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>unFix</span><span class=w> </span><span class=ow>::</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=p>(</span><span class=kt>Fix</span><span class=w> </span><span class=n>f</span><span class=p>)</span><span class=w> </span><span class=p>}</span>

<span class=nf>cata</span><span class=w> </span><span class=ow>::</span><span class=w> </span><span class=kt>Functor</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=ow>=&gt;</span><span class=w> </span><span class=kt>Algebra</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=kt>Fix</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=n>a</span>
<span class=nf>cata</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=o>.</span><span class=w> </span><span class=n>fmap</span><span class=w> </span><span class=p>(</span><span class=n>cata</span><span class=w> </span><span class=n>f</span><span class=p>)</span><span class=w> </span><span class=o>.</span><span class=w> </span><span class=n>unFix</span>
</pre></div><p></p>We can use cata to define count and depth after setting up the Functor instance of our <code>Tree</code> and the initial algebra. We also have to remove the explicit recursion from our <code>Tree</code> definition.<div class=highlight><pre tabindex=0><span></span><span class=kr>data</span><span class=w> </span><span class=kt>Tree'</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=kt>Empty'</span>
<span class=w>  </span><span class=o>|</span><span class=w> </span><span class=kt>Leaf'</span><span class=w> </span><span class=n>a</span>
<span class=w>  </span><span class=o>|</span><span class=w> </span><span class=kt>Node'</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=n>b</span>

<span class=kr>instance</span><span class=w> </span><span class=kt>Functor</span><span class=w> </span><span class=p>(</span><span class=kt>Tree'</span><span class=w> </span><span class=n>a</span><span class=p>)</span><span class=w> </span><span class=kr>where</span>
<span class=w>  </span><span class=n>fmap</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=kt>Empty'</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=kt>Empty'</span>
<span class=w>  </span><span class=n>fmap</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=p>(</span><span class=kt>Leaf'</span><span class=w> </span><span class=n>a</span><span class=p>)</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=kt>Leaf'</span><span class=w> </span><span class=n>a</span>
<span class=w>  </span><span class=n>fmap</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=p>(</span><span class=kt>Node'</span><span class=w> </span><span class=n>l</span><span class=w> </span><span class=n>r</span><span class=p>)</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=kt>Node'</span><span class=w> </span><span class=p>(</span><span class=n>f</span><span class=w> </span><span class=n>l</span><span class=p>)</span><span class=w> </span><span class=p>(</span><span class=n>f</span><span class=w> </span><span class=n>r</span><span class=p>)</span>

<span class=kr>type</span><span class=w> </span><span class=kt>FTree'</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=kt>Fix</span><span class=w> </span><span class=p>(</span><span class=kt>Tree'</span><span class=w> </span><span class=n>a</span><span class=p>)</span>

<span class=nf>count''</span><span class=w> </span><span class=ow>::</span><span class=w> </span><span class=kt>FTree'</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=kt>Int</span>
<span class=nf>count''</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>cata</span><span class=w> </span><span class=n>phi</span>
<span class=w>  </span><span class=kr>where</span>
<span class=w>    </span><span class=n>phi</span><span class=w> </span><span class=kt>Empty'</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=mi>0</span>
<span class=w>    </span><span class=n>phi</span><span class=w> </span><span class=p>(</span><span class=kt>Leaf'</span><span class=w> </span><span class=n>a</span><span class=p>)</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=mi>1</span>
<span class=w>    </span><span class=n>phi</span><span class=w> </span><span class=p>(</span><span class=kt>Node'</span><span class=w> </span><span class=n>l</span><span class=w> </span><span class=n>r</span><span class=p>)</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>l</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>r</span>

<span class=nf>depth''</span><span class=w> </span><span class=ow>::</span><span class=w> </span><span class=kt>FTree'</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=kt>Int</span>
<span class=nf>depth''</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>cata</span><span class=w> </span><span class=n>phi</span>
<span class=w>  </span><span class=kr>where</span>
<span class=w>    </span><span class=n>phi</span><span class=w> </span><span class=kt>Empty'</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=mi>0</span>
<span class=w>    </span><span class=n>phi</span><span class=w> </span><span class=p>(</span><span class=kt>Leaf'</span><span class=w> </span><span class=n>a</span><span class=p>)</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=mi>1</span>
<span class=w>    </span><span class=n>phi</span><span class=w> </span><span class=p>(</span><span class=kt>Node'</span><span class=w> </span><span class=n>l</span><span class=w> </span><span class=n>r</span><span class=p>)</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>max</span><span class=w> </span><span class=n>l</span><span class=w> </span><span class=n>r</span>
</pre></div><p></p>The functions <code>count''</code> and <code>depth''</code> on the following example tree would evaluate to 3 and 4 respectively.<div class=highlight><pre tabindex=0><span></span><span class=c1>--  /\</span>
<span class=c1>-- 3 /\</span>
<span class=c1>--  1  \</span>
<span class=c1>--      2</span>
<span class=nf>example</span><span class=w> </span><span class=ow>::</span><span class=w> </span><span class=kt>FTree'</span><span class=w> </span><span class=kt>Int</span>
<span class=nf>example</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>node</span><span class=w> </span><span class=p>(</span><span class=n>leaf</span><span class=w> </span><span class=mi>3</span><span class=p>)</span><span class=w> </span><span class=p>(</span><span class=n>node</span><span class=w> </span><span class=p>(</span><span class=n>leaf</span><span class=w> </span><span class=mi>1</span><span class=p>)</span><span class=w> </span><span class=p>(</span><span class=n>node</span><span class=w> </span><span class=n>empty</span><span class=w> </span><span class=p>(</span><span class=n>leaf</span><span class=w> </span><span class=mi>2</span><span class=p>)))</span>
<span class=w>  </span><span class=kr>where</span>
<span class=w>    </span><span class=n>empty</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=kt>Fix</span><span class=w> </span><span class=kt>Empty'</span>
<span class=w>    </span><span class=n>leaf</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=kt>Fix</span><span class=w> </span><span class=p>(</span><span class=kt>Leaf'</span><span class=w> </span><span class=n>x</span><span class=p>)</span>
<span class=w>    </span><span class=n>node</span><span class=w> </span><span class=n>l</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=kt>Fix</span><span class=w> </span><span class=p>(</span><span class=kt>Node'</span><span class=w> </span><span class=n>l</span><span class=w> </span><span class=n>r</span><span class=p>)</span>
</pre></div></section></article></main><footer>Site proudly generated by <a href=http://jaspervdj.be/hakyll>Hakyll</a>.
All content is licensed under <a href=../LICENSE.txt>3-clause BSD license</a>.</footer>