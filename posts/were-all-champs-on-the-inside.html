<!doctype html><html lang=en><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="HAMT's are cool, Haskell has a ubiquitous one in unordered-containers. But other languages have the even cooler CHAMPs. This post is about optimizing the filter-ish functions in an attempt at a drop-in replacement that uses CHAMPs."><title>(Non-)Functional Ramblings - We’re All CHAMPs On The Inside</title><style>@font-face{font-family:fira code;font-style:normal;font-weight:300 700;font-display:swap;src:local("Fira Code"),local("FiraCode"),url(/css/fonts/FiraCode-bebbb7f.woff2)format('woff2-variations')}@font-face{font-family:montserrat;font-style:normal;font-weight:100 900;font-display:swap;src:local("Montserrat"),url(/css/fonts/Montserrat-bebbb7f.woff2)format('woff2-variations')}@font-face{font-family:montserrat;font-style:italic;font-weight:100 900;font-display:swap;src:local("Montserrat Italic"),local("Montserrat-Italic"),url(/css/fonts/Montserrat-Italic-bebbb7f.woff2)format('woff2-variations')}html{font-size:80%;font-weight:400;font-family:montserrat,arial,sans-serif;scroll-behavior:smooth;scrollbar-gutter:stable}html{text-size-adjust:none}*,*::before,*::after{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;-ms-box-sizing:border-box;-o-box-sizing:border-box;box-sizing:border-box}body{line-height:1.5;-webkit-font-smoothing:antialiased}input,button,textarea,select{font:inherit}p,h1,h2,h3,h4,h5,h6{overflow-wrap:break-word}#root,#__next{isolation:isolate}body{font-size:1.6rem;background-color:#282828;color:#fbf1c7}code,pre{background-color:#1d2021}header{border-bottom:.2rem solid #98971a}nav a{font-weight:700;text-decoration:none}body img{max-width:100%;max-height:100%;display:block;margin:auto;height:auto;width:auto}body figcaption{text-align:center}footer{margin-top:3rem;padding:1.2rem 0;border-top:.2rem solid #98971a;font-size:1.2rem;color:#fbf1c7}h1{font-size:2.4rem}h2{font-size:2rem}h3{font-size:1.8rem}h4{font-size:1.6rem}.title{margin-bottom:0}article .publish-date{margin:0 0 2rem 1rem;font-size:1.4rem;color:#fbf1c7}article .last-modified-date{font-size:1rem}.logo a{font-weight:700;color:#fbf1c7;text-decoration:none}html{scrollbar-width:thick;scrollbar-color:#928374 #282828}pre{scrollbar-width:thin;scrollbar-color:#928374 #282828}nav.toc{float:left;clear:left;font-size:2rem;margin-left:-28%;width:20rem;word-wrap:break-word;padding:1rem;vertical-align:baseline;position:-webkit-sticky;position:sticky;top:5vh}nav.toc a{font-size:1.4rem}nav.toc ::marker{margin:0 -1rem 0 0}nav.toc li{margin:0;padding:0;line-height:1.2}nav.toc .toc-header{font-weight:700}nav.toc ul li{list-style-position:outside}nav.toc ul{margin-top:0;margin-bottom:0}pre,code{width:100%;font-family:fira code,consolas,monospace}div.highlight.inline{display:inline}pre{white-space:pre;overflow:auto;margin:1rem 0;background-color:#1d2021;padding:1rem;border-radius:.5rem .5rem .5rem .5rem}code{word-break:break-word;padding:0 .4rem;border-radius:.3rem .3rem .3rem .3rem}html a:link{color:#689d6a;background-color:initial;text-decoration:underline}html a:visited{color:#689d6a;background-color:initial;text-decoration:underline}html a:hover{color:#8ec07c;background-color:initial;text-decoration:underline}html a:active{color:#8ec07c;background-color:initial;text-decoration:none}nav.header a:link{color:#689d6a;background-color:initial;text-decoration:none}nav.header a:visited{color:#689d6a;background-color:initial;text-decoration:none}nav.header a:hover{color:#8ec07c;background-color:initial;text-decoration:none}nav.header a:active{color:#8ec07c;background-color:initial;text-decoration:underline}nav.toc a:link{color:#689d6a;background-color:initial;text-decoration:none}nav.toc a:visited{color:#689d6a;background-color:initial;text-decoration:none}nav.toc a:hover{color:#8ec07c;background-color:initial;text-decoration:none}nav.toc a:active{color:#8ec07c;background-color:initial;text-decoration:underline}.sidenote,marginnote{width:20rem;clear:right;font-size:1.1rem;line-height:1.3;vertical-align:baseline}body{counter-set:sidenote-counter}.sidenote-number{counter-increment:sidenote-counter}.sidenote:before{content:counter(sidenote-counter)" ";position:relative;vertical-align:baseline;font-weight:700;font-size:1rem;top:-.5rem;font-size:.9em}.sidenote-number:after{content:counter(sidenote-counter);position:relative;vertical-align:baseline;font-weight:700;font-size:1rem;top:-.5rem;left:.1rem}blockquote .sidenote,blockquote .marginnote{margin-right:82%;min-width:59%;text-align:left}.sidenote>code{font-size:1rem}label.sidenote-number{display:inline-block;max-height:2rem}label.margin-toggle:not(.sidenote-number){display:none}input.margin-toggle{display:none}@media all and (max-width:1439px){nav.toc{display:none}}@media all and (max-width:1439px){.sidenote,.marginnote{float:right;text-align:left;margin:1rem 0;padding-left:5%}}@media all and (min-width:1440px){.sidenote,.marginnote{float:right;margin-right:-30%;margin-top:.3rem;margin-bottom:0;position:relative}}@media all and (max-width:639px){body{width:100%;margin:0;padding:0 5%}header{margin:1rem 0}nav.header{margin:.5rem auto;text-align:center}footer{text-align:center}nav.header a{font-size:1.4rem;line-height:1.6}.logo{font-size:1.8rem}nav.header a{margin:0 .6rem}}@media all and (min-width:640px){body{width:70rem;margin:0 auto;padding:0}header{margin:0 0 3rem;padding:.6rem 0 .2rem}nav.header{display:flex;align-items:flex-end;justify-content:space-between;margin:0;text-align:right}nav.header a{font-size:1.8rem;margin:0 0 0 .6rem;display:inline}.navigation{justify-content:flex-end}footer{text-align:right}.logo{margin:0;text-align:left;font-size:2.4rem}}pre{line-height:125%}td.linenos .normal{color:#3c4354;background-color:initial;padding-left:5px;padding-right:5px}span.linenos{color:#3c4354;background-color:initial;padding-left:5px;padding-right:5px}td.linenos .special{color:#3c4354;background-color:#ffffc0;padding-left:5px;padding-right:5px}span.linenos.special{color:#3c4354;background-color:#ffffc0;padding-left:5px;padding-right:5px}.hll{background-color:#6e7681}.c{color:#7e8aa1}.err{color:#f88f7f}.esc{color:#d4d2c8}.g{color:#d4d2c8}.k{color:#ffad66}.l{color:#d5ff80}.n{color:#d4d2c8}.o{color:#ffad66}.x{color:#d4d2c8}.p{color:#d4d2c8}.ch{color:#f88f7f;font-style:italic}.cm{color:#7e8aa1}.cp{color:#ffad66;font-weight:700}.cpf{color:#7e8aa1}.c1{color:#7e8aa1}.cs{color:#7e8aa1;font-style:italic}.gd{color:#f88f7f;background-color:#3d1e20}.ge{color:#d4d2c8;font-style:italic}.ges{color:#d4d2c8}.gr{color:#f88f7f}.gh{color:#d4d2c8}.gi{color:#6ad4af;background-color:#19362c}.go{color:#7e8aa1}.gp{color:#d4d2c8}.gs{color:#d4d2c8;font-weight:700}.gu{color:#d4d2c8}.gt{color:#f88f7f}.kc{color:#ffad66}.kd{color:#ffad66}.kn{color:#ffad66}.kp{color:#ffad66}.kr{color:#ffad66}.kt{color:#73d0ff}.ld{color:#d5ff80}.m{color:#dfbfff}.s{color:#d5ff80}.na{color:#ffd173}.nb{color:#ffd173}.nc{color:#73d0ff}.no{color:#ffd173}.nd{color:#7e8aa1;font-weight:700;font-style:italic}.ni{color:#95e6cb}.ne{color:#73d0ff}.nf{color:#ffd173}.nl{color:#d4d2c8}.nn{color:#d4d2c8}.nx{color:#d4d2c8}.py{color:#ffd173}.nt{color:#5ccfe6}.nv{color:#d4d2c8}.ow{color:#ffad66}.pm{color:#d4d2c8}.w{color:#d4d2c8}.mb{color:#dfbfff}.mf{color:#dfbfff}.mh{color:#dfbfff}.mi{color:#dfbfff}.mo{color:#dfbfff}.sa{color:#f29e74}.sb{color:#d5ff80}.sc{color:#d5ff80}.dl{color:#d5ff80}.sd{color:#7e8aa1}.s2{color:#d5ff80}.se{color:#95e6cb}.sh{color:#d5ff80}.si{color:#95e6cb}.sx{color:#95e6cb}.sr{color:#95e6cb}.s1{color:#d5ff80}.ss{color:#dfbfff}.bp{color:#5ccfe6}.fm{color:#ffd173}.vc{color:#d4d2c8}.vg{color:#d4d2c8}.vi{color:#d4d2c8}.vm{color:#d4d2c8}.il{color:#dfbfff}</style><link rel=preload href=../css/fonts/Montserrat-bebbb7f.woff2 crossorigin=anonymous as=font type=font/woff2><link rel=stylesheet href=../css/katex.css media=print onload='this.media="all"'><noscript><link rel=stylesheet href=../css/katex.css></noscript><link rel="shortcut icon" href=favicon.ico type=image/x-icon><link rel="shortcut icon" href=../images/favicons/favicon32.png><link rel=apple-touch-icon-precomposed sizes=144x144 href=../images/favicons/favicon144.png><link rel=apple-touch-icon-precomposed sizes=114x114 href=../images/favicons/favicon114.png><link rel=apple-touch-icon-precomposed sizes=72x72 href=../images/favicons/favicon72.png><link rel=apple-touch-icon-precomposed sizes=57x57 href=../images/favicons/favicon57.png><header><nav class=header><a class=logo href=../>(Non-)Functional Ramblings</a><div class=navigation><a href=../about.html>About</a>
<a href=../static/resume.pdf>Resume</a>
<a href=../archive.html>Archive</a>
<a href=../atom.xml>Feed</a></div></nav></header><main role=main><h1 class=title>We’re All <strong><em>CHAMP</em></strong>s On The Inside</h1><article><section class=publish-date><em>Posted on March 24, 2025
</em><em class=last-modified-date>last modified on March 31, 2025</em></section><section><nav class=toc><div class=toc-header>Contents</div><ul><li><a href=#can-i-eat-it id=toc-can-i-eat-it>Can I Eat It?</a><li><a href=#gotta-start-somewhere id=toc-gotta-start-somewhere>Gotta Start Somewhere</a><li><a href=#when-children-thrash-around id=toc-when-children-thrash-around>When Children Thrash Around</a><li><a href=#nothing-but-lies id=toc-nothing-but-lies>Nothing But Lies</a></ul></nav><p></p>HAMT’s are cool, Haskell has a ubiquitous one in <a href=https://hackage.haskell.org/package/unordered-containers-0.2.20/><code>unordered-containers</code></a>. But other languages have the <a href=https://michael.steindorfer.name/publications/oopsla15.pdf>even cooler CHAMPs</a>. This post is about optimizing the <code>filter</code>-ish functions in <a href=https://github.com/Qqwy/haskell-champ>an attempt at a drop-in replacement</a> of <code>unordered-containers</code> by my colleague <a href=http://wmcode.nl/>Marten</a> that uses CHAMP.<h2 id=can-i-eat-it>Can I Eat It?</h2><p></p>I’ll assume some familiarity with how HAMT works, but will summarize it very shortly as a trie on hash codes, implementing persistent hash maps and -sets. In code, a hash map based on HAMT may look like the following<label for=sn-0 class="margin-toggle sidenote-number"></label><input type=checkbox id=sn-0 class=margin-toggle><div class=sidenote><a href=https://hackage.haskell.org/package/contiguous-0.6.4.2>contiguous</a> is used everywhere in <code>haskell-champ</code>, in code snippets in this post, I’ll be eliding where functions come from, but you can probably safely assume they’re in that package somewhere.</div><label for=sn-1 class="margin-toggle sidenote-number"></label><input type=checkbox id=sn-1 class=margin-toggle><div class=sidenote>There’s also a <code>Full</code> node that is “full” and contains the maximum number of child nodes. I’ve omitted this for brevity.</div>:<div class=highlight><pre tabindex=0><span></span><span class=kr>data</span><span class=w> </span><span class=kt>Hashmap</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=n>v</span>
<span class=w>  </span><span class=ow>=</span><span class=w> </span><span class=kt>Empty</span>
<span class=w>  </span><span class=c1>-- ^ Used to only describe an empty hash map</span>
<span class=w>  </span><span class=o>|</span><span class=w> </span><span class=kt>Leaf</span><span class=w> </span><span class=kt>Hash</span><span class=w> </span><span class=p>(</span><span class=n>k</span><span class=p>,</span><span class=w> </span><span class=n>v</span><span class=p>)</span>
<span class=w>  </span><span class=c1>-- ^ A singular key and corresponding value,</span>
<span class=w>  </span><span class=c1>-- along with the memoized hash of the key</span>
<span class=w>  </span><span class=o>|</span><span class=w> </span><span class=kt>Collision</span><span class=w> </span><span class=kt>Hash</span><span class=w> </span><span class=p>(</span><span class=kt>Array</span><span class=w> </span><span class=p>(</span><span class=n>k</span><span class=p>,</span><span class=w> </span><span class=n>v</span><span class=p>))</span>
<span class=w>  </span><span class=c1>-- ^ A hash collision node, where the hashes of all of</span>
<span class=w>  </span><span class=c1>-- it's elements are indistinguishable.</span>
<span class=w>  </span><span class=o>|</span><span class=w> </span><span class=kt>BitmapIndexed</span><span class=w> </span><span class=kt>Word32</span><span class=w> </span><span class=p>(</span><span class=kt>Array</span><span class=w> </span><span class=p>(</span><span class=kt>HashMap</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=n>v</span><span class=p>))</span>
<span class=w>  </span><span class=c1>-- ^ The main juice, the bitmap encodes where in</span>
<span class=w>  </span><span class=c1>-- the array a key may be located, based on a segment</span>
<span class=w>  </span><span class=c1>-- of its hash.</span>
</pre></div><p></p>The <code>Bitmap</code> in <code>BitmapIndexed</code> encodes the segment of the hash relevant to the node. To give an example let’s say we inserted <code>5</code> and <code>13</code> with the fixed hash partition size of <code>3</code>. Using the identity hash function that maps <code>5</code> to <code>0101</code> and <code>13</code> to <code>1101</code>, we get that <code>5</code> and <code>13</code> both have the same first segment of <code>hash & (2^3 - 1) == 101</code>. We then check the next 3 bits and do find that they differ at <code>(hash >> 3) & (2^3 - 1) == (1 for 13 and 0 for 5)</code>.<figure><p></p><img src=../images/mmd_0zGH0x3B_Zg.svg title=mermaid-figure alt="Structure of a hash map implemented using HAMT containing 5 and 13."><figcaption aria-hidden=true>Structure of a hash map implemented using HAMT containing 5 and 13.</figcaption></figure><p></p>As the name implies, CHAMP (compressed hash array mapped prefix-tree), uses a more compact representation, where the leaves are inlined where possible. To differentiate between inline entries and child nodes, 2 bitmaps are used instead of one. This is phrased approximately in <code>haskell-champ</code> as the following.<div class=highlight><pre tabindex=0><span></span><span class=kr>data</span><span class=w> </span><span class=kt>MapNode</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=n>v</span>
<span class=w>  </span><span class=c1>-- ^ Unpack the bitmap into a separate data type.</span>
<span class=w>  </span><span class=ow>=</span><span class=w> </span><span class=kt>Compact</span><span class=w> </span><span class=kt>Word64</span><span class=w> </span><span class=p>(</span><span class=kt>Array</span><span class=w> </span><span class=n>k</span><span class=p>)</span><span class=w> </span><span class=p>(</span><span class=kt>Array</span><span class=w> </span><span class=n>v</span><span class=p>)</span><span class=w> </span><span class=p>(</span><span class=kt>Array</span><span class=w> </span><span class=p>(</span><span class=kt>MapNode</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=n>v</span><span class=p>))</span>
<span class=w>  </span><span class=c1>-- ^ This time we have a single bitmap, but split it in 2.</span>
<span class=w>  </span><span class=c1>-- The first half shows which keys are present inline,</span>
<span class=w>  </span><span class=c1>-- while the second half shows which children should be</span>
<span class=w>  </span><span class=c1>-- checked for the key.</span>
<span class=w>  </span><span class=o>|</span><span class=w> </span><span class=kt>Collision</span><span class=w> </span><span class=p>(</span><span class=kt>Array</span><span class=w> </span><span class=n>k</span><span class=p>)</span><span class=w> </span><span class=p>(</span><span class=kt>Array</span><span class=w> </span><span class=n>v</span><span class=p>)</span>

<span class=kr>data</span><span class=w> </span><span class=kt>Hashmap</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=n>v</span>
<span class=w>  </span><span class=ow>=</span><span class=w> </span><span class=kt>Empty</span>
<span class=w>  </span><span class=o>|</span><span class=w> </span><span class=kt>Singleton</span><span class=w> </span><span class=kt>Hash</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=n>v</span>
<span class=w>  </span><span class=c1>-- ^ Use the Word otherwise used for the bitmap, to store the</span>
<span class=w>  </span><span class=c1>-- Hash of the only key we have.</span>
<span class=w>  </span><span class=o>|</span><span class=w> </span><span class=kt>ManyMap</span><span class=w> </span><span class=kt>Word</span><span class=w> </span><span class=p>(</span><span class=kt>MapNode</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=n>v</span><span class=p>)</span>
<span class=w>  </span><span class=c1>-- ^ Also memoize the number of items in the hash map.</span>
</pre></div><figure><p></p><img src=../images/mmd_41C1558dfHk.svg title=mermaid-figure alt="Same hash map, but now using CHAMP."><figcaption aria-hidden=true>Same hash map, but now using CHAMP.</figcaption></figure><p></p>You may notice that the hash-memoization isn’t present anymore, I’d encourage you to check out the paper, as the authors tested both with-and-without memoization forms. As a library, <code>haskell-champ</code> makes some additional nifty improvements, which I’d also encourage you to check out! Important for this blog post is that sizes are memoized instead of hashes.<h2 id=gotta-start-somewhere>Gotta Start Somewhere</h2><p></p>Before you optimize, gotta do some groundwork, so you know what you’re measuring. We’ll be optimizing the <code>filterWithKey</code> function with the approximate<label for=sn-2 class="margin-toggle sidenote-number"></label><input type=checkbox id=sn-2 class=margin-toggle><div class=sidenote>I say approximate, because the type signature is a bit more complicated, due to the way haskell-champ is written to support lifted/unlifted/boxed/unboxed datatypes.</div>type signature and base implementation that goes via <code>List</code>.<div class=highlight><pre tabindex=0><span></span><span class=nf>filterWithKey</span><span class=w> </span><span class=ow>::</span><span class=w> </span><span class=p>(</span><span class=n>k</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=kt>Bool</span><span class=p>)</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=kt>HashMap</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=kt>HashMap</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=n>v</span>
<span class=nf>filterWithKey</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>fromList</span><span class=w> </span><span class=o>.</span><span class=w> </span><span class=kt>List</span><span class=o>.</span><span class=n>filter</span><span class=w> </span><span class=p>(</span><span class=n>uncurry</span><span class=w> </span><span class=n>f</span><span class=p>)</span><span class=w> </span><span class=o>.</span><span class=w>  </span><span class=n>toList</span>
</pre></div><p></p>Running a <code>tasty-bench</code> run of the base implementation against <code>unordered-containers</code>’ variant with the hash maps being constructed out of <code>[0..n)</code> and the filter function being <code>even</code><label for=sn-3 class="margin-toggle sidenote-number"></label><input type=checkbox id=sn-3 class=margin-toggle><div class=sidenote>I know, I know, microbenchmarks… There are definite biases here, and you can probably pretty easily spot them. With the hash map depth likely not getting large enough to be significant, and <code>even</code> always halving the hash map. Still though, pretty nice to get an idea of how this approximately performs in at least this specific case. I’ll get back to this at the end.</div>.<div class=highlight><pre tabindex=0><span></span><span class=nf>build</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>force</span><span class=w> </span><span class=o>$</span><span class=w> </span><span class=n>fromList</span><span class=w> </span><span class=p>[(</span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=n>x</span><span class=p>)</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=ow>&lt;-</span><span class=w> </span><span class=p>[</span><span class=mi>0</span><span class=w> </span><span class=o>..</span><span class=w> </span><span class=p>(</span><span class=n>n</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=mi>1</span><span class=p>)]]</span>
</pre></div><table><col style=width:47%><col style=width:52%><tbody><tr class=odd><td><img src=../images/champ-filter-base-cputime.png><td><img src=../images/champ-filter-base-allocations.png></table><p></p>Running the benchmarks using the naive implementation gives an expected picture, with the naive implementation being ~6x slower and allocating ~22x more. Now the fun can start.<h2 id=when-children-thrash-around>When Children Thrash Around</h2><p></p>The first thing we have to do is plan out how we plan to filter out values from the trie. As there are entries both inline and within children, we’ll have to enumerate both. So concretely, in order to maintain as compact a representation as possible.<ol type=1><li>Go over children nodes and run the filter across them.<ol type=1><li>Remove any child nodes that become empty.<li>When a child node only contains a single inline entry, bring it inline.</ol><li>Run the filter across the inline entries.<ol type=1><li>If we have to inline any child nodes, do so on the output.</ol><li>Ensure the bitmap is kept in sync with the elements in each array.</ol><p></p>We’ll go over these steps in turn. Firstly, we’ll have to go over the child nodes. This is the point where we do a recursive call. It is useful to realize that there are 3 distinct cases. The child node can either be empty, contain a single entry, where we will have to inline that entry, or have <code>>1</code> elements. In the last case, we’ll have to ensure that the child node maintains the correct structure, i.e. its bitmap is consistent with what it contains.<div class=highlight><pre tabindex=0><span></span><span class=kr>data</span><span class=w> </span><span class=kt>RecursiveFilterOutput</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=n>v</span>
<span class=w>  </span><span class=ow>=</span><span class=w> </span><span class=kt>EmptyChildNode</span>
<span class=w>  </span><span class=o>|</span><span class=w> </span><span class=kt>InlineEntry</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=n>v</span>
<span class=w>  </span><span class=o>|</span><span class=w> </span><span class=kt>FilteredChild</span><span class=w> </span><span class=p>(</span><span class=kt>MapNode</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=n>v</span><span class=p>)</span>
</pre></div><p></p>This looks a lot like how we defined our <code>HashMap</code>! With a bit of massaging, we can use <code>HashMap</code> instead and do a recursive call to our same filtering function we were defining, no unrelated data types or conversions necessary. When we inline an entry, because we use a unified representation for all cases, the <code>InlineEntry</code> case has an empty bitmap it can actually use to store the hash of the key. Perfect, because we need that hash in order to insert the entry into the inline arrays. So we strictly only calculate hashes of keys we need to move up, and nothing else.<p></p>The compact structure of our nodes, used for the inline keys and values is useful for cache locality, but less so when we need to execute a function on elements in tandem, now having to put elements in new arrays conditionally. One could phrase this as a incremental fold on two new empty arrays. So something akin to the following.<div class=highlight><pre tabindex=0><span></span><span class=nf>filterKeysValues</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>keys</span><span class=w> </span><span class=n>values</span><span class=w> </span><span class=ow>=</span>
<span class=w>  </span><span class=kr>let</span><span class=w> </span><span class=n>check</span><span class=w> </span><span class=p>(</span><span class=n>ks</span><span class=p>,</span><span class=w> </span><span class=n>vs</span><span class=p>)</span><span class=w> </span><span class=n>ix</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=ow>=</span>
<span class=w>        </span><span class=kr>let</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>index</span><span class=w> </span><span class=n>values</span><span class=w> </span><span class=n>ix</span>
<span class=w>         </span><span class=kr>in</span><span class=w> </span><span class=kr>if</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=n>v</span>
<span class=w>              </span><span class=kr>then</span><span class=w> </span><span class=p>(</span><span class=n>ks</span><span class=p>,</span><span class=w> </span><span class=n>vs</span><span class=p>)</span>
<span class=w>              </span><span class=kr>else</span><span class=w> </span><span class=p>(</span><span class=n>insertAt</span><span class=w> </span><span class=n>ks</span><span class=w> </span><span class=p>(</span><span class=n>size</span><span class=w> </span><span class=n>ks</span><span class=p>)</span><span class=w> </span><span class=n>k</span><span class=p>,</span><span class=w> </span><span class=n>insertAt</span><span class=w> </span><span class=n>vs</span><span class=w> </span><span class=p>(</span><span class=n>size</span><span class=w> </span><span class=n>vs</span><span class=p>)</span><span class=w> </span><span class=n>v</span><span class=p>)</span>
<span class=w>   </span><span class=kr>in</span><span class=w> </span><span class=n>ifoldl'</span><span class=w> </span><span class=n>check</span><span class=w> </span><span class=p>(</span><span class=n>empty</span><span class=p>,</span><span class=w> </span><span class=n>empty</span><span class=p>)</span><span class=w> </span><span class=n>keys</span>
</pre></div><p></p>This isn’t that great though. When inserting into the array, it’s dynamically resized every time the array grows past what it was allocated for. Instead, we’d ideally allocate the right size immediately when copying over references and avoid any resizes. We can do this by executing <code>f</code> over all keys and values first, capturing information in a bitmask, and only afterwards copy from the original arrays into new ones using this bitmask.<div class=highlight><pre tabindex=0><span></span><span class=nf>bitmask</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=o>!</span><span class=n>keys</span><span class=w> </span><span class=o>!</span><span class=n>values</span><span class=w> </span><span class=ow>=</span>
<span class=w>  </span><span class=kr>let</span><span class=w> </span><span class=n>createMask</span><span class=w> </span><span class=o>!</span><span class=n>acc</span><span class=w> </span><span class=o>!</span><span class=n>ix</span><span class=w> </span><span class=o>!</span><span class=n>k</span><span class=w> </span><span class=o>!</span><span class=n>v</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=kr>if</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=kr>then</span><span class=w> </span><span class=n>acc</span><span class=w> </span><span class=p>`</span><span class=n>setBit</span><span class=p>`</span><span class=w> </span><span class=n>ix</span><span class=w> </span><span class=kr>else</span><span class=w> </span><span class=n>acc</span>
<span class=w>      </span><span class=o>!</span><span class=n>mask</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>ifoldlZipWith'</span><span class=w> </span><span class=n>createMask</span><span class=w> </span><span class=n>zeroBits</span><span class=w> </span><span class=n>keys</span><span class=w> </span><span class=n>values</span>
<span class=w>  </span><span class=kr>in</span><span class=w>  </span><span class=n>mask</span>

<span class=nf>filterKeysValues</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=o>!</span><span class=n>keys</span><span class=w> </span><span class=o>!</span><span class=n>values</span><span class=w> </span><span class=ow>=</span>
<span class=w>  </span><span class=kr>let</span><span class=w> </span><span class=o>!</span><span class=n>mask</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>bitmask</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>keys</span><span class=w> </span><span class=n>values</span>
<span class=w>      </span><span class=o>!</span><span class=n>keys'</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>filterUsingMask</span><span class=w> </span><span class=n>keys</span><span class=w> </span><span class=n>mask</span>
<span class=w>      </span><span class=o>!</span><span class=n>values'</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>filterUsingMask</span><span class=w> </span><span class=n>values</span><span class=w> </span><span class=n>mask</span>
<span class=w>  </span><span class=kr>in</span><span class=w> </span><span class=p>(</span><span class=n>mask</span><span class=p>,</span><span class=w> </span><span class=n>keys'</span><span class=p>,</span><span class=w> </span><span class=n>values'</span><span class=p>)</span>
</pre></div><p></p>These new key and value arrays are smaller than the originals, losing some entries it previously contained inline. The entries that were deleted need to be removed from the bitmask. Because we don’t memoize hashes, we’ll have to recompute them. The naive approach would go over all the keys we kept/or deleted, and set or unset respectively, the corresponding bits in the bitmap.<p></p>One thing to note is that the relative indices in the bitmap, denote the locations in the actual contiguous arrays. Now that we have a boolean mask, we can overlay that on the set bits in the bitmap, and get the bitmap of the filtered items, all without hashing!<div class=highlight><pre tabindex=0><span></span><span class=nf>maskBitmap</span><span class=w> </span><span class=o>!</span><span class=n>booleanMask</span><span class=w> </span><span class=o>!</span><span class=n>bitmap</span><span class=w> </span><span class=ow>=</span>
<span class=w>  </span><span class=n>go</span><span class=w> </span><span class=n>booleanMask</span><span class=w> </span><span class=n>bitmap</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=mi>0</span>
<span class=w> </span><span class=kr>where</span>
<span class=w>  </span><span class=n>go</span><span class=w> </span><span class=o>!</span><span class=kr>_</span><span class=w> </span><span class=o>!</span><span class=mi>0</span><span class=w> </span><span class=o>!</span><span class=n>acc</span><span class=w> </span><span class=o>!</span><span class=kr>_</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>acc</span>
<span class=w>  </span><span class=n>go</span><span class=w> </span><span class=o>!</span><span class=mi>0</span><span class=w> </span><span class=o>!</span><span class=kr>_</span><span class=w> </span><span class=o>!</span><span class=n>acc</span><span class=w> </span><span class=o>!</span><span class=kr>_</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>acc</span>
<span class=w>  </span><span class=n>go</span><span class=w> </span><span class=o>!</span><span class=n>booleanMask</span><span class=w> </span><span class=o>!</span><span class=n>bitmap</span><span class=w> </span><span class=o>!</span><span class=n>acc</span><span class=w> </span><span class=o>!</span><span class=n>ix</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>bitmap</span><span class=w> </span><span class=o>.&amp;.</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span>
<span class=w>    </span><span class=ow>=</span><span class=w> </span><span class=n>go</span><span class=w> </span><span class=n>booleanMask</span><span class=w> </span><span class=p>(</span><span class=n>bitmap</span><span class=w> </span><span class=o>!&gt;&gt;.</span><span class=w> </span><span class=mi>1</span><span class=p>)</span><span class=w> </span><span class=n>acc</span><span class=w> </span><span class=p>(</span><span class=n>ix</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1</span><span class=p>)</span>
<span class=w>  </span><span class=n>go</span><span class=w> </span><span class=o>!</span><span class=n>booleanMask</span><span class=w> </span><span class=o>!</span><span class=n>bitmap</span><span class=w> </span><span class=o>!</span><span class=n>acc</span><span class=w> </span><span class=o>!</span><span class=n>ix</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>booleanMask</span><span class=w> </span><span class=o>.&amp;.</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span>
<span class=w>    </span><span class=ow>=</span><span class=w> </span><span class=n>go</span><span class=w> </span><span class=p>(</span><span class=n>booleanMask</span><span class=w> </span><span class=o>!&gt;&gt;.</span><span class=w> </span><span class=mi>1</span><span class=p>)</span><span class=w> </span><span class=p>(</span><span class=n>bitmap</span><span class=w> </span><span class=o>!&gt;&gt;.</span><span class=w> </span><span class=mi>1</span><span class=p>)</span><span class=w> </span><span class=n>acc</span><span class=w> </span><span class=p>(</span><span class=n>ix</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1</span><span class=p>)</span>
<span class=w>  </span><span class=n>go</span><span class=w> </span><span class=o>!</span><span class=n>booleanMask</span><span class=w> </span><span class=o>!</span><span class=n>bitmap</span><span class=w> </span><span class=o>!</span><span class=n>acc</span><span class=w> </span><span class=o>!</span><span class=n>ix</span>
<span class=w>    </span><span class=ow>=</span><span class=w> </span><span class=n>go</span><span class=w> </span><span class=p>(</span><span class=n>booleanMask</span><span class=w> </span><span class=o>!&gt;&gt;.</span><span class=w> </span><span class=mi>1</span><span class=p>)</span><span class=w> </span><span class=p>(</span><span class=n>bitmap</span><span class=w> </span><span class=o>!&gt;&gt;.</span><span class=w> </span><span class=mi>1</span><span class=p>)</span><span class=w> </span><span class=p>(</span><span class=n>acc</span><span class=w> </span><span class=p>`</span><span class=n>setBit</span><span class=p>`</span><span class=w> </span><span class=n>ix</span><span class=p>)</span><span class=w> </span><span class=p>(</span><span class=n>ix</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1</span><span class=p>)</span>
</pre></div><p></p>Wrapping these up, leads to the following nicer picture.<table><col style=width:47%><col style=width:52%><tbody><tr class=odd><td><img src=../images/champ-filter-new-cputime.png><td><img src=../images/champ-filter-new-allocations.png></table><h2 id=nothing-but-lies>Nothing But Lies</h2><p></p>Benchmarking is always very tricky. At this point I had my fill for the moment and stopped looking for improvements. <a href=https://github.com/Qqwy/haskell-champ/pull/19>I made the commit and pushed it.</a> The unfortunate thing about microbenchmarks though, is that minor deviations can give very different pictures. While the above graphs shows that we’re pretty close, just changing the key to <code>ShortText</code> instead of <code>Int</code>, already worsens the improvement we had of -11%, to +72% relative to <code>unordered-containers</code>.<table><col style=width:47%><col style=width:52%><tbody><tr class=odd><td><img src=../images/champ-filter-text-cputime.png><td><img src=../images/champ-filter-text-allocations.png></table><p></p>Even better, the fact that the hash map in the benchmark is constructed out of <code>fromList [(x, x) | x &lt;- [0 .. (n - 1)]]</code> is already problematic in combination with using <code>even</code> as the filter. Changing the hash map where the keys and values are uniformly selected <code>i64</code>, shows a closer picture to the run with <code>ShortText</code>.<table><col style=width:47%><col style=width:52%><tbody><tr class=odd><td><img src=../images/champ-filter-random-cputime.png><td><img src=../images/champ-filter-random-allocations.png></table><p></p>So, while I end with a nice improvement relative to what I started with, it isn’t an improvement on the status quo, so my enthusiasm has calmed down a bit. Pretty fun exercise in world’s best imperative programming language though.</section></article></main><footer>Site proudly generated by <a href=http://jaspervdj.be/hakyll>Hakyll</a>.
All content is licensed under <a href=../LICENSE.txt>3-clause BSD license</a>.</footer>