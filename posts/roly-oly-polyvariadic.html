<!doctype html><html lang=en><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="This blog post illustrates the concept of polyvariadic functions, using the example of a function that can sum an arbitrary number of integers or return another function."><title>(Non-)Functional Ramblings - Roly, Oly, …, Polyvariadic</title><style>@font-face{font-family:fira code;font-style:normal;font-weight:300 700;font-display:swap;src:local("Fira Code"),local("FiraCode"),url(/css/fonts/FiraCode-e2dae25.woff2)format('woff2-variations')}@font-face{font-family:montserrat;font-style:normal;font-weight:100 900;font-display:swap;src:local("Montserrat"),url(/css/fonts/Montserrat-e2dae25.woff2)format('woff2-variations')}@font-face{font-family:montserrat;font-style:italic;font-weight:100 900;font-display:swap;src:local("Montserrat Italic"),local("Montserrat-Italic"),url(/css/fonts/Montserrat-Italic-e2dae25.woff2)format('woff2-variations')}html{font-size:80%;font-weight:400;font-family:montserrat,arial,sans-serif;scroll-behavior:smooth;scrollbar-gutter:stable}html{text-size-adjust:none}*,*::before,*::after{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;-ms-box-sizing:border-box;-o-box-sizing:border-box;box-sizing:border-box}body{line-height:1.5;-webkit-font-smoothing:antialiased}input,button,textarea,select{font:inherit}p,h1,h2,h3,h4,h5,h6{overflow-wrap:break-word}#root,#__next{isolation:isolate}body{font-size:1.6rem;background-color:#282828;color:#fbf1c7}code,pre{background-color:#1d2021}header{border-bottom:.2rem solid #98971a}nav a{font-weight:700;text-decoration:none}body img{max-width:100%;max-height:100%;display:block;margin:auto;height:auto}body figcaption{text-align:center}footer{margin-top:3rem;padding:1.2rem 0;border-top:.2rem solid #98971a;font-size:1.2rem;color:#fbf1c7}h1{font-size:2.4rem}h2{font-size:2rem}h3{font-size:1.8rem}h4{font-size:1.6rem}.title{margin-bottom:0}article .publish-date{margin:0 0 2rem 1rem;font-size:1.4rem;color:#fbf1c7}.logo a{font-weight:700;color:#fbf1c7;text-decoration:none}html{scrollbar-width:thick;scrollbar-color:#928374 #282828}pre{scrollbar-width:thin;scrollbar-color:#928374 #282828}nav.toc{float:left;clear:left;font-size:2rem;margin-left:-28%;width:20rem;word-wrap:break-word;padding:1rem;vertical-align:baseline;position:-webkit-sticky;position:sticky;top:5vh}nav.toc a{font-size:1.4rem}nav.toc ::marker{margin:0 -1rem 0 0}nav.toc li{margin:0;padding:0;line-height:1.2}nav.toc .toc-header{font-weight:700}nav.toc ul li{list-style-position:outside}nav.toc ul{margin-top:0;margin-bottom:0}pre,code{width:100%;font-family:fira code,consolas,monospace}div.highlight.inline{display:inline}pre{white-space:pre;overflow:auto;margin:1rem 0;background-color:#1d2021;padding:1rem;border-radius:.5rem .5rem .5rem .5rem}code{word-break:break-word;padding:0 .4rem;border-radius:.3rem .3rem .3rem .3rem}html a:link{color:#689d6a;background-color:initial;text-decoration:underline}html a:visited{color:#689d6a;background-color:initial;text-decoration:underline}html a:hover{color:#8ec07c;background-color:initial;text-decoration:underline}html a:active{color:#8ec07c;background-color:initial;text-decoration:none}nav.header a:link{color:#689d6a;background-color:initial;text-decoration:none}nav.header a:visited{color:#689d6a;background-color:initial;text-decoration:none}nav.header a:hover{color:#8ec07c;background-color:initial;text-decoration:none}nav.header a:active{color:#8ec07c;background-color:initial;text-decoration:underline}nav.toc a:link{color:#689d6a;background-color:initial;text-decoration:none}nav.toc a:visited{color:#689d6a;background-color:initial;text-decoration:none}nav.toc a:hover{color:#8ec07c;background-color:initial;text-decoration:none}nav.toc a:active{color:#8ec07c;background-color:initial;text-decoration:underline}.sidenote,marginnote{width:20rem;clear:right;font-size:1.1rem;line-height:1.3;vertical-align:baseline}body{counter-set:sidenote-counter}.sidenote-number{counter-increment:sidenote-counter}.sidenote:before{content:counter(sidenote-counter)" ";position:relative;vertical-align:baseline;font-weight:700;font-size:1rem;top:-.5rem;font-size:.9em}.sidenote-number:after{content:counter(sidenote-counter);position:relative;vertical-align:baseline;font-weight:700;font-size:1rem;top:-.5rem;left:.1rem}blockquote .sidenote,blockquote .marginnote{margin-right:82%;min-width:59%;text-align:left}.sidenote>code{font-size:1rem}label.sidenote-number{display:inline-block;max-height:2rem}label.margin-toggle:not(.sidenote-number){display:none}input.margin-toggle{display:none}@media all and (max-width:1439px){nav.toc{display:none}}@media all and (max-width:1439px){.sidenote,.marginnote{float:right;text-align:left;margin:1rem 0;padding-left:5%}}@media all and (min-width:1440px){.sidenote,.marginnote{float:right;margin-right:-30%;margin-top:.3rem;margin-bottom:0;position:relative}}@media all and (max-width:639px){body{width:100%;margin:0;padding:0 5%}header{margin:1rem 0}nav.header{margin:.5rem auto;text-align:center}footer{text-align:center}nav.header a{font-size:1.4rem;line-height:1.6}.logo{font-size:1.8rem}nav.header a{margin:0 .6rem}}@media all and (min-width:640px){body{width:70rem;margin:0 auto;padding:0}header{margin:0 0 3rem;padding:.6rem 0 .2rem}nav.header{display:flex;align-items:flex-end;justify-content:space-between;margin:0;text-align:right}nav.header a{font-size:1.8rem;margin:0 0 0 .6rem;display:inline}.navigation{justify-content:flex-end}footer{text-align:right}.logo{margin:0;text-align:left;font-size:2.4rem}}pre{line-height:125%}td.linenos .normal{color:#3c4354;background-color:initial;padding-left:5px;padding-right:5px}span.linenos{color:#3c4354;background-color:initial;padding-left:5px;padding-right:5px}td.linenos .special{color:#3c4354;background-color:#ffffc0;padding-left:5px;padding-right:5px}span.linenos.special{color:#3c4354;background-color:#ffffc0;padding-left:5px;padding-right:5px}.hll{background-color:#6e7681}.c{color:#7e8aa1}.err{color:#f88f7f}.esc{color:#d4d2c8}.g{color:#d4d2c8}.k{color:#ffad66}.l{color:#d5ff80}.n{color:#d4d2c8}.o{color:#ffad66}.x{color:#d4d2c8}.p{color:#d4d2c8}.ch{color:#f88f7f;font-style:italic}.cm{color:#7e8aa1}.cp{color:#ffad66;font-weight:700}.cpf{color:#7e8aa1}.c1{color:#7e8aa1}.cs{color:#7e8aa1;font-style:italic}.gd{color:#f88f7f;background-color:#3d1e20}.ge{color:#d4d2c8;font-style:italic}.ges{color:#d4d2c8}.gr{color:#f88f7f}.gh{color:#d4d2c8}.gi{color:#6ad4af;background-color:#19362c}.go{color:#7e8aa1}.gp{color:#d4d2c8}.gs{color:#d4d2c8;font-weight:700}.gu{color:#d4d2c8}.gt{color:#f88f7f}.kc{color:#ffad66}.kd{color:#ffad66}.kn{color:#ffad66}.kp{color:#ffad66}.kr{color:#ffad66}.kt{color:#73d0ff}.ld{color:#d5ff80}.m{color:#dfbfff}.s{color:#d5ff80}.na{color:#ffd173}.nb{color:#ffd173}.nc{color:#73d0ff}.no{color:#ffd173}.nd{color:#7e8aa1;font-weight:700;font-style:italic}.ni{color:#95e6cb}.ne{color:#73d0ff}.nf{color:#ffd173}.nl{color:#d4d2c8}.nn{color:#d4d2c8}.nx{color:#d4d2c8}.py{color:#ffd173}.nt{color:#5ccfe6}.nv{color:#d4d2c8}.ow{color:#ffad66}.pm{color:#d4d2c8}.w{color:#d4d2c8}.mb{color:#dfbfff}.mf{color:#dfbfff}.mh{color:#dfbfff}.mi{color:#dfbfff}.mo{color:#dfbfff}.sa{color:#f29e74}.sb{color:#d5ff80}.sc{color:#d5ff80}.dl{color:#d5ff80}.sd{color:#7e8aa1}.s2{color:#d5ff80}.se{color:#95e6cb}.sh{color:#d5ff80}.si{color:#95e6cb}.sx{color:#95e6cb}.sr{color:#95e6cb}.s1{color:#d5ff80}.ss{color:#dfbfff}.bp{color:#5ccfe6}.fm{color:#ffd173}.vc{color:#d4d2c8}.vg{color:#d4d2c8}.vi{color:#d4d2c8}.vm{color:#d4d2c8}.il{color:#dfbfff}</style><link rel=preload href=../css/fonts/Montserrat-e2dae25.woff2 crossorigin=anonymous as=font type=font/woff2><link rel=stylesheet href=../css/katex.css media=print onload='this.media="all"'><noscript><link rel=stylesheet href=../css/katex.css></noscript><link rel="shortcut icon" href=favicon.ico type=image/x-icon><link rel="shortcut icon" href=../images/favicons/favicon32.png><link rel=apple-touch-icon-precomposed sizes=144x144 href=../images/favicons/favicon144.png><link rel=apple-touch-icon-precomposed sizes=114x114 href=../images/favicons/favicon114.png><link rel=apple-touch-icon-precomposed sizes=72x72 href=../images/favicons/favicon72.png><link rel=apple-touch-icon-precomposed sizes=57x57 href=../images/favicons/favicon57.png><header><nav class=header><a class=logo href=../>(Non-)Functional Ramblings</a><div class=navigation><a href=../about.html>About</a>
<a href=../static/resume.pdf>Resume</a>
<a href=../archive.html>Archive</a>
<a href=../atom.xml>Feed</a></div></nav></header><main role=main><h1 class=title>Roly, Oly, …, Polyvariadic</h1><article><section class=publish-date><em>Posted on July 6, 2019</em></section><section><p></p>During my undergraduates, I followed a course called <em>Functional Programming</em>. That course mainly dealt with getting your feet wet with Haskell and some light fp theory. At that point, most students followed the course on imperative programming just half a year ago and then get blasted with the whole higher order functions deal. I definitely doubt I understood what monads were at the end of it.<p></p>Now during my master’s studies, I followed a course on “Advanced Functional Programming”. One of the topics that came up during the explanation of monad transformers were functional dependencies and type families – these looked a lot like magic.<p></p>One of the many things that is possible with these extensions, is polyvariadic functions, functions which take an arbitrary number of parameters<label for=sn-0 class="margin-toggle sidenote-number"></label><input type=checkbox id=sn-0 class=margin-toggle><div class=sidenote><a href=http://okmij.org/ftp/Haskell/polyvariadic.html#polyvar-fn>An explanation of the polyvariadic function technique</a>”</div>. One example included in ghc is <code>Text.PrintF</code>, which mimics the C-inspired function <code>printf</code> with its, at first glance, weird type signature <code>PrintfType r => String -> r</code>.<p></p>The main idea behind this, is to have a function that can result in either another function or a final value. In the printf example, this is accomplished using the <code>PrintfType</code> type class.<p></p>As an example, let’s define a function which sums a variable number of integers. The result of the function is either an int or a function which takes an int, and gives the same choice. We can keep this choice of possible types as the type variable of the class.<div class=highlight><pre tabindex=0><span></span><span class=kr>class</span><span class=w> </span><span class=kt>AddP</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=kr>where</span>
<span class=w>    </span><span class=n>addP</span><span class=w> </span><span class=ow>::</span><span class=w> </span><span class=kt>Int</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=n>r</span>
</pre></div><p></p>Defining the instance which will lead to the final value should be easy. The type variable <code>r</code> just becomes an <code>Int</code>.<div class=highlight><pre tabindex=0><span></span><span class=kr>instance</span><span class=w> </span><span class=kt>AddP</span><span class=w> </span><span class=kt>Int</span><span class=w> </span><span class=kr>where</span>
<span class=w>    </span><span class=n>addP</span><span class=w> </span><span class=ow>::</span><span class=w> </span><span class=kt>Int</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=kt>Int</span>
<span class=w>    </span><span class=n>addP</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>id</span>
</pre></div><p></p>The case where the function needs to return a function is only slightly more complex. The first instinct is to create an instance for <code>Int -> r</code>. This could look like:<div class=highlight><pre tabindex=0><span></span><span class=kr>instance</span><span class=w> </span><span class=kt>AddP</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=ow>=&gt;</span><span class=w> </span><span class=kt>AddP</span><span class=w> </span><span class=p>(</span><span class=kt>Int</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=n>r</span><span class=p>)</span><span class=w> </span><span class=kr>where</span>
<span class=w>    </span><span class=n>addP</span><span class=w> </span><span class=ow>::</span><span class=w> </span><span class=kt>Int</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=kt>Int</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=n>r</span>
<span class=w>    </span><span class=n>addP</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>addP</span><span class=w> </span><span class=p>(</span><span class=n>x</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>y</span><span class=p>)</span>
</pre></div><p></p>This is, however, too limiting. Trying to execute <code>addP 1 2</code> gives an error message which, while kind of vague, gives an idea as to why.<div class=highlight><pre tabindex=0><span></span><span class=o>&lt;</span><span class=n>interactive</span><span class=o>&gt;:</span><span class=mi>1</span><span class=kt>:</span><span class=mi>1</span><span class=kt>:</span><span class=w> </span><span class=ne>error</span><span class=kt>:</span>
<span class=w>    </span><span class=err>•</span><span class=w> </span><span class=kt>No</span><span class=w> </span><span class=kr>instance</span><span class=w> </span><span class=n>for</span><span class=w> </span><span class=p>(</span><span class=kt>AddP</span><span class=w> </span><span class=p>(</span><span class=kt>Integer</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=kt>Integer</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=kt>Int</span><span class=p>))</span>
<span class=w>        </span><span class=n>arising</span><span class=w> </span><span class=n>from</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=n>use</span><span class=w> </span><span class=kr>of</span><span class=w> </span><span class=err>‘</span><span class=n>add</span><span class=err>’</span>
<span class=w>        </span><span class=p>(</span><span class=n>maybe</span><span class=w> </span><span class=n>you</span><span class=w> </span><span class=n>haven't</span><span class=w> </span><span class=n>applied</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=n>function</span><span class=w> </span><span class=n>to</span><span class=w> </span><span class=n>enough</span><span class=w> </span><span class=n>arguments</span><span class=o>?</span><span class=p>)</span>
<span class=w>    </span><span class=err>•</span><span class=w> </span><span class=kt>In</span><span class=w> </span><span class=n>the</span><span class=w> </span><span class=n>expression</span><span class=kt>:</span><span class=w> </span><span class=n>add</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=ow>::</span><span class=w> </span><span class=kt>Int</span>
<span class=w>      </span><span class=kt>In</span><span class=w> </span><span class=n>an</span><span class=w> </span><span class=n>equation</span><span class=w> </span><span class=n>for</span><span class=w> </span><span class=err>‘</span><span class=n>it</span><span class=err>’</span><span class=kt>:</span><span class=w> </span><span class=n>it</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>add</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=ow>::</span><span class=w> </span><span class=kt>Int</span>
</pre></div><p></p>The best effort hint ghc gives here is pretty useless in our case, as we clearly give 2 arguments to the function. The real problem is our usage of the plus operator and our arguments. The plus operator is defined over all instances of the <code>Num</code> type class, and integers in haskell can be anything from Int, Integer, Natural, or even Float. So using the function needs a lot more type annotations to work. This is evident by the fact that <code>addP (1 :: Int) (2 :: Int) :: Int</code> does indeed typecheck.<p></p>We need to expand the cases this instance captures. One way to do this, is to use equality constraints, aka. the type level <code>~</code> operator. Writing <code>a ~ b</code> means that we additionally require that <code>a</code> and <code>b</code> should be nominally equal. This is different from using, for example just <code>a</code> in every position where <code>b</code> would appear.<p></p>When ghc tries to look up an instance, it tries to find any matching instances. If we only write an instance for <code>Int</code>, when it tries to match an instance for <code>Integer</code>, it can’t find anything. A different situation pops up, however, if we write an instance for <code>a</code> and then constrain that <code>a</code> to be <code>Int</code>s. This instance will always be matched due to the very generic type <code>a -> r</code>, while still maintaining the <code>Int</code> constraint. Note that this will still crash if no appropriate instance can be found; trying to match <code>String</code> with an instance written with an <code>Int</code> constraint, for example, will still fail. The following works when executed with <code>addP 1 2 3 :: Int</code>.<div class=highlight><pre tabindex=0><span></span><span class=kr>instance</span><span class=w> </span><span class=p>(</span><span class=kt>AddP</span><span class=w> </span><span class=n>r</span><span class=p>,</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>~</span><span class=w> </span><span class=kt>Int</span><span class=p>)</span><span class=w> </span><span class=ow>=&gt;</span><span class=w> </span><span class=kt>AddP</span><span class=w> </span><span class=p>(</span><span class=n>a</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=n>r</span><span class=p>)</span><span class=w> </span><span class=kr>where</span>
<span class=w>    </span><span class=n>addP</span><span class=w> </span><span class=ow>::</span><span class=w> </span><span class=kt>Int</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=n>r</span>
<span class=w>    </span><span class=n>addP</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>addP</span><span class=w> </span><span class=p>(</span><span class=n>x</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>y</span><span class=p>)</span>

<span class=nf>add</span><span class=w> </span><span class=ow>::</span><span class=w> </span><span class=kt>AddP</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=ow>=&gt;</span><span class=w> </span><span class=n>a</span>
<span class=nf>add</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>addP</span><span class=w> </span><span class=mi>0</span>
</pre></div><p></p>We can reuse the previous flow to create polyvariadic variations of <code>unwords</code> and <code>(:)</code>. The <code>lists</code> function is not an exact mirror, because of <code>(:)</code> requiring a list to append to. The last function, <code>lists</code>, just builds a list from the given arguments<div class=highlight><pre tabindex=0><span></span><span class=kr>class</span><span class=w> </span><span class=kt>WordP</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=kr>where</span>
<span class=w>    </span><span class=n>unwordP</span><span class=w> </span><span class=ow>::</span><span class=w> </span><span class=kt>String</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=n>r</span>

<span class=kr>instance</span><span class=w> </span><span class=kt>WordP</span><span class=w> </span><span class=kt>String</span><span class=w> </span><span class=kr>where</span>
<span class=w>    </span><span class=n>unwordP</span><span class=w> </span><span class=ow>::</span><span class=w> </span><span class=kt>String</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=kt>String</span>
<span class=w>    </span><span class=n>unwordP</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>drop</span><span class=w> </span><span class=mi>1</span>

<span class=kr>instance</span><span class=w> </span><span class=p>(</span><span class=kt>WordP</span><span class=w> </span><span class=n>res</span><span class=p>,</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>~</span><span class=w> </span><span class=kt>String</span><span class=p>)</span><span class=w> </span><span class=ow>=&gt;</span><span class=w> </span><span class=kt>WordP</span><span class=w> </span><span class=p>(</span><span class=n>a</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=n>res</span><span class=p>)</span><span class=w> </span><span class=kr>where</span>
<span class=w>    </span><span class=n>unwordP</span><span class=w> </span><span class=ow>::</span><span class=w> </span><span class=kt>String</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=n>res</span>
<span class=w>    </span><span class=n>unwordP</span><span class=w> </span><span class=n>xs</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>unwordP</span><span class=w> </span><span class=p>(</span><span class=n>unwords</span><span class=w> </span><span class=p>[</span><span class=n>xs</span><span class=p>,</span><span class=w> </span><span class=n>x</span><span class=p>])</span>

<span class=nf>unword</span><span class=w> </span><span class=ow>::</span><span class=w> </span><span class=kt>WordP</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=ow>=&gt;</span><span class=w> </span><span class=n>a</span>
<span class=nf>unword</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>unwordP</span><span class=w> </span><span class=kt>[]</span>

<span class=kr>class</span><span class=w> </span><span class=kt>ListP</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=kr>where</span>
<span class=w>    </span><span class=kr>type</span><span class=w> </span><span class=kt>LArg</span><span class=w> </span><span class=n>r</span>
<span class=w>    </span><span class=n>listsP</span><span class=w> </span><span class=ow>::</span><span class=w> </span><span class=p>[</span><span class=kt>LArg</span><span class=w> </span><span class=n>r</span><span class=p>]</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=n>r</span>

<span class=kr>instance</span><span class=w> </span><span class=kt>ListP</span><span class=w> </span><span class=p>[</span><span class=n>a</span><span class=p>]</span><span class=w> </span><span class=kr>where</span>
<span class=w>    </span><span class=kr>type</span><span class=w> </span><span class=kt>LArg</span><span class=w> </span><span class=p>[</span><span class=n>a</span><span class=p>]</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>a</span>
<span class=w>    </span><span class=n>listsP</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>reverse</span>

<span class=kr>instance</span><span class=w> </span><span class=p>(</span><span class=kt>ListP</span><span class=w> </span><span class=n>r</span><span class=p>,</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>~</span><span class=w> </span><span class=kt>LArg</span><span class=w> </span><span class=n>r</span><span class=p>)</span><span class=w> </span><span class=ow>=&gt;</span><span class=w> </span><span class=kt>ListP</span><span class=w> </span><span class=p>(</span><span class=n>a</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=n>r</span><span class=p>)</span><span class=w> </span><span class=kr>where</span>
<span class=w>    </span><span class=kr>type</span><span class=w> </span><span class=kt>LArg</span><span class=w> </span><span class=p>(</span><span class=n>a</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=n>r</span><span class=p>)</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>a</span>
<span class=w>    </span><span class=n>listsP</span><span class=w> </span><span class=n>xs</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>listsP</span><span class=w> </span><span class=p>(</span><span class=n>x</span><span class=w> </span><span class=kt>:</span><span class=w> </span><span class=n>xs</span><span class=p>)</span>

<span class=nf>lists</span><span class=w> </span><span class=ow>::</span><span class=w> </span><span class=kt>ListP</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=ow>=&gt;</span><span class=w> </span><span class=n>r</span>
<span class=nf>lists</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>listsP</span><span class=w> </span><span class=kt>[]</span>
</pre></div><p></p>The above <code>add</code> function and <code>AddP</code> type class can be greatly improved. It currently only accepts arguments of type <code>Int</code>, while the only operator it makes use of, <code>(+)</code>, is defined over all instances of the <code>Num</code> type class. Ideally, we would like our function to also be defined over those same instances. Examples of what we would have liked to see are:<div class=highlight><pre tabindex=0><span></span><span class=o>&gt;</span><span class=w> </span><span class=n>add</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=ow>::</span><span class=w> </span><span class=kt>Int</span>
<span class=mi>6</span>
<span class=o>&gt;</span><span class=w> </span><span class=n>add</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=mf>2.4</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=ow>::</span><span class=w> </span><span class=kt>Float</span>
<span class=mf>6.4</span>
</pre></div><p></p>We can use the <code>Num</code> constraint in the type class definition and instance declarations to achieve this, in most cases this just means switching out the <code>Int</code>s with the constrained variable. We also add an extra type variable which will contain the information over which type we’re currently operating.<div class=highlight><pre tabindex=0><span></span><span class=kr>class</span><span class=w> </span><span class=kt>Num</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=ow>=&gt;</span><span class=w> </span><span class=kt>Add</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=kr>where</span>
<span class=w>    </span><span class=n>addN</span><span class=w> </span><span class=ow>::</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=n>r</span>
</pre></div><p></p>One problem is the instance we write for values. We can’t really write an instance for <code>(Num a, a ~ r) => Add a r</code>, because the <code>r</code> type variable is too generic and captures too much.<p></p>One solution to this problem is the <em>OverlappingInstances</em> extension. This extension allows multiple instance definitions to be written where the applicable types overlap. In our case the <code>Add a r</code> instance would overlap with any other instance for <code>Add</code>, like <code>Add a (a -> r)</code>.<p></p>We can, in a limited capacity, annotate specific instances to be preferred over others. So in situations where both <code>Add a r</code> and <code>Add a (a -> r)</code> matched, we would prefer that <code>Add a (a -> r)</code> be picked. The resulting definitions are:<div class=highlight><pre tabindex=0><span></span><span class=kr>class</span><span class=w> </span><span class=kt>Num</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=ow>=&gt;</span><span class=w> </span><span class=kt>Add</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=kr>where</span>
<span class=w>    </span><span class=n>addN</span><span class=w> </span><span class=ow>::</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=n>r</span>

<span class=kr>instance</span><span class=w> </span><span class=cm>{-# OVERLAPPABLE #-}</span><span class=w> </span><span class=p>(</span><span class=kt>Num</span><span class=w> </span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>~</span><span class=w> </span><span class=n>r</span><span class=p>)</span><span class=w> </span><span class=ow>=&gt;</span><span class=w> </span><span class=kt>Add</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=kr>where</span>
<span class=w>    </span><span class=n>addN</span><span class=w> </span><span class=ow>::</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=n>r</span>
<span class=w>    </span><span class=n>addN</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>id</span>

<span class=kr>instance</span><span class=w> </span><span class=cm>{-# OVERLAPPING #-}</span><span class=w> </span><span class=p>(</span><span class=kt>Add</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=n>r</span><span class=p>,</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>~</span><span class=w> </span><span class=n>a'</span><span class=p>)</span><span class=w> </span><span class=ow>=&gt;</span><span class=w> </span><span class=kt>Add</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=p>(</span><span class=n>a'</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=n>r</span><span class=p>)</span><span class=w> </span><span class=kr>where</span>
<span class=w>    </span><span class=n>addN</span><span class=w> </span><span class=ow>::</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=ow>-&gt;</span><span class=w> </span><span class=n>r</span>
<span class=w>    </span><span class=n>addN</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=ow>=</span><span class=w> </span><span class=n>addN</span><span class=w> </span><span class=p>(</span><span class=n>x</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>y</span><span class=p>)</span>
</pre></div><p></p>One big annoyance is the fact that we have to create a type class per polyvariadic function. Next time we’ll try and look at approaches to generalizing this process.</section></article></main><footer>Site proudly generated by <a href=http://jaspervdj.be/hakyll>Hakyll</a>.
All content is licensed under <a href=../LICENSE.txt>3-clause BSD license</a>.</footer>